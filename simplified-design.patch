diff --git a/.github/workflows/docs.yaml b/.github/workflows/docs.yaml
index 466e3ebe7ed656e83bb9d6768f7fd2c5503a30f3..b19f224839998a677e7a2d08a9dd459ba1b25583 100644
--- a/.github/workflows/docs.yaml
+++ b/.github/workflows/docs.yaml
@@ -4,9 +4,17 @@ on:
   push:
   workflow_dispatch:
 
+permissions:
+  contents: read
+  pages: write
+  id-token: write
+
 jobs:
   docs:
     runs-on: ubuntu-24.04
+    environment:
+      name: github-pages
+      url: ${{ steps.deployment.outputs.page_url }}
     steps:
       - name: Checkout repo
         uses: actions/checkout@v4
diff --git a/README.md b/README.md
index 9806e075a574d73b028a63324bb099c5157dc00e..a14a0bcb90723251e79d9c60f7ebbfaf56bf1c29 100644
--- a/README.md
+++ b/README.md
@@ -1,42 +1,102 @@
 ![](../../workflows/gds/badge.svg) ![](../../workflows/docs/badge.svg) ![](../../workflows/test/badge.svg) ![](../../workflows/fpga/badge.svg)
 
-# Tiny Tapeout Verilog Project Template
+# Audio Tone Generator & FM Transmitter
 
-- [Read the documentation for project](docs/info.md)
+A TinyTapeout FM transmitter project featuring musical tone generation using Direct Digital Synthesis (DDS). This design plays a C-major scale pattern via FM modulation.
 
-## What is Tiny Tapeout?
+- [Read the full documentation](docs/info.md)
 
-Tiny Tapeout is an educational project that aims to make it easier and cheaper than ever to get your digital and analog designs manufactured on a real chip.
+## Features
 
-To learn more and get started, visit https://tinytapeout.com.
+- üéµ **Musical Tone Generation**: Plays a 16-note C-major scale pattern
+- üìª **FM Modulation**: Generates FM-modulated RF output signal (~12.5 MHz)
+- üîä **Audio Output**: Direct audio-frequency square wave output
+- üîÅ **Loop Mode**: Continuous melody playback
+- üìä **Debug Outputs**: Status monitoring and control signals
+- ‚ö° **Optimized Design**: Simplified for efficient ASIC implementation
 
-## Set up your Verilog project
+## How It Works
 
-1. Add your Verilog files to the `src` folder.
-2. Edit the [info.yaml](info.yaml) and update information about your project, paying special attention to the `source_files` and `top_module` properties. If you are upgrading an existing Tiny Tapeout project, check out our [online info.yaml migration tool](https://tinytapeout.github.io/tt-yaml-upgrade-tool/).
-3. Edit [docs/info.md](docs/info.md) and add a description of your project.
-4. Adapt the testbench to your design. See [test/README.md](test/README.md) for more information.
+The design uses Direct Digital Synthesis (DDS) with a 32-bit phase accumulator to generate precise frequencies for both audio tones and FM carrier signals. A melody ROM stores a 16-note C-major scale which is sequenced and converted to FM-modulated RF output at ~12.5 MHz.
 
-The GitHub action will automatically build the ASIC files using [LibreLane](https://www.zerotoasiccourse.com/terminology/librelane/).
+Key components:
+- **Melody ROM**: 16-note C-major scale pattern
+- **DDS Engine**: 32-bit phase accumulator for frequency synthesis
+- **FM Modulator**: Modulates carrier with audio tones
+- **Audio Generator**: Creates audio-frequency square wave output
+- **Sequencer**: Controls note timing and progression
 
-## Enable GitHub actions to build the results page
+### Block Diagram
 
-- [Enabling GitHub Pages](https://tinytapeout.com/faq/#my-github-action-is-failing-on-the-pages-part)
+```
+‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
+‚îÇ   Melody    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  Frequency   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ     FM      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ fm_out
+‚îÇ    ROM      ‚îÇ     ‚îÇ  Calculator  ‚îÇ     ‚îÇ  Modulator  ‚îÇ
+‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
+                           ‚îÇ
+                           ‚îÇ
+                           ‚ñº
+                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
+                    ‚îÇ    Audio     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ audio_out
+                    ‚îÇ  Generator   ‚îÇ
+                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
+```
 
-## Resources
+## Quick Start
 
-- [FAQ](https://tinytapeout.com/faq/)
-- [Digital design lessons](https://tinytapeout.com/digital_design/)
-- [Learn how semiconductors work](https://tinytapeout.com/siliwiz/)
-- [Join the community](https://tinytapeout.com/discord)
-- [Build your design locally](https://www.tinytapeout.com/guides/local-hardening/)
+### Basic Usage
 
-## What next?
+1. Set `enable` (ui[0]) high to start playback
+2. Set `loop` (ui[1]) high for continuous playback
+3. Monitor `fm_out` (uo[0]) for FM signal
+4. Monitor `audio_out` (uo[1]) with speaker/oscilloscope
 
-- [Submit your design to the next shuttle](https://app.tinytapeout.com/).
-- Edit [this README](README.md) and explain your design, how it works, and how to test it.
-- Share your project on your social network of choice:
-  - LinkedIn [#tinytapeout](https://www.linkedin.com/search/results/content/?keywords=%23tinytapeout) [@TinyTapeout](https://www.linkedin.com/company/100708654/)
-  - Mastodon [#tinytapeout](https://chaos.social/tags/tinytapeout) [@matthewvenn](https://chaos.social/@matthewvenn)
-  - X (formerly Twitter) [#tinytapeout](https://twitter.com/hashtag/tinytapeout) [@tinytapeout](https://twitter.com/tinytapeout)
-  - Bluesky [@tinytapeout.com](https://bsky.app/profile/tinytapeout.com)
+### Pin Mapping
+
+| Pin | Name | Description |
+|-----|------|-------------|
+| ui[0] | enable | Enable playback |
+| ui[1] | loop | Loop melody continuously |
+| uo[0] | fm_out | FM modulated RF output |
+| uo[1] | audio_out | Audio frequency output |
+| uo[2] | playing | Melody playing status |
+| uo[3] | melody_end | End of melody pulse |
+
+## Technical Specifications
+
+- **Clock Frequency**: 50 MHz
+- **FM Carrier**: ~12.5 MHz
+- **Tempo**: 120 BPM
+- **Melody**: 16-note C-major scale
+- **Architecture**: Fully synthesizable Verilog
+- **Target**: GF180MCU ASIC (1x1 tiles)
+
+## Testing
+
+The project includes cocotb-based testbenches:
+
+```bash
+cd test
+make
+```
+
+Tests verify:
+- Melody playback enable/disable
+- Loop mode functionality
+- Status signal generation
+- Basic FM modulator operation
+
+## External Hardware (Optional)
+
+1. **FM Receiver**: Tune to ~12.5 MHz to receive FM signal
+2. **Speaker/Buzzer**: Connect to `audio_out` for direct audio
+3. **Oscilloscope**: For signal monitoring and debugging
+
+## Design Optimizations
+
+The design has been optimized for ASIC implementation:
+- ‚úÖ Simplified 16-note melody (vs. 82-note F√ºr Elise)
+- ‚úÖ Reduced lookup tables for area efficiency
+- ‚úÖ Pure behavioral Verilog (no vendor primitives)
+- ‚úÖ Single clock domain
+- ‚úÖ Fully synthesizable for GF180MCU
diff --git a/docs/info.md b/docs/info.md
index ce1f04c223c5b4dc125ab66d74caf18164c2ca00..1a0c5bc78d1b8d91c17464b6ace25d8f32529ca4 100644
--- a/docs/info.md
+++ b/docs/info.md
@@ -9,12 +9,81 @@ You can also include images in this folder and reference them in the markdown. E
 
 ## How it works
 
-Explain how your project works
+This project is an FM transmitter with musical tone generation using Direct Digital Synthesis (DDS). It plays a 16-note C-major scale pattern via FM modulation. The design has been optimized for efficient ASIC implementation.
+
+### Core Components
+
+**Direct Digital Synthesis (DDS)**: Uses a 32-bit phase accumulator that increments each clock cycle. The MSB toggles at the desired output frequency, creating square wave tones with precise frequency control.
+
+**Melody Generation**: A ROM stores 16 notes of a C-major scale with duration information. The melody sequencer reads notes sequentially, calculates appropriate frequencies, and drives both the audio and FM modulators.
+
+**FM Modulation**: Audio tones modulate the carrier frequency by adjusting the phase increment of the FM modulator. This creates frequency deviation around a ~12.5 MHz center carrier frequency.
+
+**Audio Generator**: Creates audio-frequency square wave output directly from the note frequencies, suitable for driving speakers or buzzers.
+
+**Sequencer**: Controls note timing and progression through the melody, with support for looping playback.
+
+The design outputs both the FM-modulated RF signal and a direct audio-frequency square wave for speakers or debugging.
 
 ## How to test
 
-Explain how to use your project
+### Basic Melody Playback
+
+1. Set `enable` (ui[0]) high to start playback
+2. Set `loop` (ui[1]) high for continuous playback
+3. Monitor `fm_out` (uo[0]) for the FM modulated RF signal
+4. Monitor `audio_out` (uo[1]) for audio frequency output (connect to speaker/buzzer)
+5. Observe `playing` (uo[2]) status - should go high when melody is active
+
+### Status Monitoring
+
+- `playing` (uo[2]): High when melody is active
+- `melody_end` (uo[3]): Pulses at the end of each melody cycle
+- `status[3:0]` (uo[7:4]): Additional status information
+- `bidir_out[7:0]` (uio[7:0]): Bidirectional output pins (configured as outputs)
+
+### Expected Behavior
+
+- When enabled without loop: Plays the 16-note C-major scale once and stops
+- When enabled with loop: Plays the C-major scale continuously
+- FM carrier operates at ~12.5 MHz
+- Audio output provides direct tone generation for speaker/buzzer
 
 ## External hardware
 
-List external hardware used in your project (e.g. PMOD, LED display, etc), if any
+### Optional External Hardware
+
+1. **FM Receiver**: To receive and demodulate the FM signal from `fm_out`
+   - Tune to approximately 12.5 MHz
+   - May require amplification and antenna for best results
+
+2. **Speaker/Buzzer**: Connect to `audio_out` for direct audio playback
+   - Small piezo buzzer or 8Œ© speaker with suitable driver
+   - Output is a square wave at audio frequencies (C4-C5 range)
+
+3. **Oscilloscope** (recommended for testing):
+   - Monitor FM carrier on `fm_out`
+   - Observe audio waveforms on `audio_out`
+   - Measure signal characteristics
+
+### No External Hardware Required
+
+The design is fully functional without any external hardware:
+- Internal melody plays automatically when enabled
+- All signals can be monitored on output pins
+- Self-contained demonstration of FM modulation and DDS principles
+
+### Pin Connections Summary
+
+| Pin | Name | Direction | Description |
+|-----|------|-----------|-------------|
+| ui[0] | enable | Input | Enable playback |
+| ui[1] | loop | Input | Loop melody continuously |
+| ui[2] | - | Input | Unused |
+| ui[3] | - | Input | Unused |
+| uo[0] | fm_out | Output | FM modulated RF output |
+| uo[1] | audio_out | Output | Audio frequency output |
+| uo[2] | playing | Output | Melody playing status |
+| uo[3] | melody_end | Output | End of melody pulse |
+| uo[7:4] | status | Output | Status bits |
+| uio[7:0] | bidir_out | Output | Bidirectional outputs |
diff --git a/info.yaml b/info.yaml
index 75edd84fba904ae3b95cd26d8afb31aca867e386..7b91f6f0d52c463a198953244d8445b503e6d092 100644
--- a/info.yaml
+++ b/info.yaml
@@ -1,9 +1,9 @@
 # Tiny Tapeout project information
 project:
   title:        "Audio Tone Generator & FM Transmitter"
-  author:       "r4d10n (amply supported by Claude Code :)"
+  author:       "Rakesh Peter"
   discord:      ""
-  description:  "FM transmitter with audio tone generation and melody playback via DDS"
+  description:  "FM transmitter / Tone Generator"
   language:     "Verilog"
   clock_hz:     50000000  # 50 MHz
 
@@ -23,8 +23,6 @@ project:
     - "melody_sequencer.v"
     - "fm_modulator.v"
     - "audio_tone_generator.v"
-    - "clock_doubler.v"
-    - "pwm_input_decoder.v"
 
 # The pinout of your project. Leave unused pins blank. DO NOT delete or add any pins.
 # This section is for the datasheet/website. Use descriptive names (e.g., RX, TX, MOSI, SCL, SEG_A, etc.).
@@ -32,8 +30,8 @@ pinout:
   # Inputs
   ui[0]: "enable"
   ui[1]: "loop"
-  ui[2]: "clk_2x_enable"
-  ui[3]: "pwm_in"
+  ui[2]: ""
+  ui[3]: ""
   ui[4]: ""
   ui[5]: ""
   ui[6]: ""
@@ -44,20 +42,20 @@ pinout:
   uo[1]: "audio_out"
   uo[2]: "playing"
   uo[3]: "melody_end"
-  uo[4]: "note_index[0]"
-  uo[5]: "note_index[1]"
-  uo[6]: "note_index[2]"
-  uo[7]: "note_index[3]"
+  uo[4]: "status[0]"
+  uo[5]: "status[1]"
+  uo[6]: "status[2]"
+  uo[7]: "status[3]"
 
   # Bidirectional pins
-  uio[0]: "phase_inc[24]"
-  uio[1]: "phase_inc[25]"
-  uio[2]: "phase_inc[26]"
-  uio[3]: "phase_inc[27]"
-  uio[4]: "phase_inc[28]"
-  uio[5]: "phase_inc[29]"
-  uio[6]: "phase_inc[30]"
-  uio[7]: "phase_inc[31]"
+  uio[0]: "bidir_out[0]"
+  uio[1]: "bidir_out[1]"
+  uio[2]: "bidir_out[2]"
+  uio[3]: "bidir_out[3]"
+  uio[4]: "bidir_out[4]"
+  uio[5]: "bidir_out[5]"
+  uio[6]: "bidir_out[6]"
+  uio[7]: "bidir_out[7]"
 
 # Do not change!
 yaml_version: 6
diff --git a/simplified-design.patch b/simplified-design.patch
new file mode 100644
index 0000000000000000000000000000000000000000..9a6e40eded16d3888f30c13cdc0efcba37d4c532
--- /dev/null
+++ b/simplified-design.patch
@@ -0,0 +1,1251 @@
+diff --git a/.github/workflows/docs.yaml b/.github/workflows/docs.yaml
+index 466e3eb..b19f224 100644
+--- a/.github/workflows/docs.yaml
++++ b/.github/workflows/docs.yaml
+@@ -4,9 +4,17 @@ on:
+   push:
+   workflow_dispatch:
+ 
++permissions:
++  contents: read
++  pages: write
++  id-token: write
++
+ jobs:
+   docs:
+     runs-on: ubuntu-24.04
++    environment:
++      name: github-pages
++      url: ${{ steps.deployment.outputs.page_url }}
+     steps:
+       - name: Checkout repo
+         uses: actions/checkout@v4
+diff --git a/README.md b/README.md
+index 9806e07..60ee3bd 100644
+--- a/README.md
++++ b/README.md
+@@ -1,27 +1,125 @@
+ ![](../../workflows/gds/badge.svg) ![](../../workflows/docs/badge.svg) ![](../../workflows/test/badge.svg) ![](../../workflows/fpga/badge.svg)
+ 
+-# Tiny Tapeout Verilog Project Template
++# Audio Tone Generator & FM Transmitter
+ 
+-- [Read the documentation for project](docs/info.md)
++A TinyTapeout FM transmitter project featuring musical tone generation using Direct Digital Synthesis (DDS). This design plays a C-major scale pattern via FM modulation.
+ 
+-## What is Tiny Tapeout?
++- [Read the full documentation](docs/info.md)
+ 
+-Tiny Tapeout is an educational project that aims to make it easier and cheaper than ever to get your digital and analog designs manufactured on a real chip.
++## Features
+ 
+-To learn more and get started, visit https://tinytapeout.com.
++- üéµ **Musical Tone Generation**: Plays a 16-note C-major scale pattern
++- üìª **FM Modulation**: Generates FM-modulated RF output signal (~12.5 MHz)
++- üîä **Audio Output**: Direct audio-frequency square wave output
++- üîÅ **Loop Mode**: Continuous melody playback
++- üìä **Debug Outputs**: Status monitoring and control signals
++- ‚ö° **Optimized Design**: Simplified for efficient ASIC implementation
++
++## How It Works
++
++The design uses Direct Digital Synthesis (DDS) with a 32-bit phase accumulator to generate precise frequencies for both audio tones and FM carrier signals. A melody ROM stores a 16-note C-major scale which is sequenced and converted to FM-modulated RF output at ~12.5 MHz.
++
++Key components:
++- **Melody ROM**: 16-note C-major scale pattern
++- **DDS Engine**: 32-bit phase accumulator for frequency synthesis
++- **FM Modulator**: Modulates carrier with audio tones
++- **Audio Generator**: Creates audio-frequency square wave output
++- **Sequencer**: Controls note timing and progression
++
++### Block Diagram
++
++```
++‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
++‚îÇ   Melody    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  Frequency   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ     FM      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ fm_out
++‚îÇ    ROM      ‚îÇ     ‚îÇ  Calculator  ‚îÇ     ‚îÇ  Modulator  ‚îÇ
++‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
++                           ‚îÇ
++                           ‚îÇ
++                           ‚ñº
++                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
++                    ‚îÇ    Audio     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ audio_out
++                    ‚îÇ  Generator   ‚îÇ
++                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
++```
++
++## Quick Start
++
++### Basic Usage
++
++1. Set `enable` (ui[0]) high to start playback
++2. Set `loop` (ui[1]) high for continuous playback
++3. Monitor `fm_out` (uo[0]) for FM signal
++4. Monitor `audio_out` (uo[1]) with speaker/oscilloscope
++
++### Pin Mapping
++
++| Pin | Name | Description |
++|-----|------|-------------|
++| ui[0] | enable | Enable playback |
++| ui[1] | loop | Loop melody continuously |
++| uo[0] | fm_out | FM modulated RF output |
++| uo[1] | audio_out | Audio frequency output |
++| uo[2] | playing | Melody playing status |
++| uo[3] | melody_end | End of melody pulse |
++
++## Technical Specifications
++
++- **Clock Frequency**: 50 MHz
++- **FM Carrier**: ~12.5 MHz
++- **Tempo**: 120 BPM
++- **Melody**: 16-note C-major scale
++- **Architecture**: Fully synthesizable Verilog
++- **Target**: GF180MCU ASIC (1x2 tiles)
++
++## Testing
+ 
+-## Set up your Verilog project
++The project includes cocotb-based testbenches:
+ 
+-1. Add your Verilog files to the `src` folder.
+-2. Edit the [info.yaml](info.yaml) and update information about your project, paying special attention to the `source_files` and `top_module` properties. If you are upgrading an existing Tiny Tapeout project, check out our [online info.yaml migration tool](https://tinytapeout.github.io/tt-yaml-upgrade-tool/).
+-3. Edit [docs/info.md](docs/info.md) and add a description of your project.
+-4. Adapt the testbench to your design. See [test/README.md](test/README.md) for more information.
++```bash
++cd test
++make
++```
+ 
+-The GitHub action will automatically build the ASIC files using [LibreLane](https://www.zerotoasiccourse.com/terminology/librelane/).
++Tests verify:
++- Melody playback enable/disable
++- Loop mode functionality
++- Status signal generation
++- Basic FM modulator operation
+ 
+-## Enable GitHub actions to build the results page
++## External Hardware (Optional)
+ 
+-- [Enabling GitHub Pages](https://tinytapeout.com/faq/#my-github-action-is-failing-on-the-pages-part)
++1. **FM Receiver**: Tune to ~12.5 MHz to receive FM signal
++2. **Speaker/Buzzer**: Connect to `audio_out` for direct audio
++3. **Oscilloscope**: For signal monitoring and debugging
++
++## Design Optimizations
++
++The design has been optimized for ASIC implementation:
++- ‚úÖ Simplified 16-note melody (vs. 82-note F√ºr Elise)
++- ‚úÖ Reduced lookup tables for area efficiency
++- ‚úÖ Pure behavioral Verilog (no vendor primitives)
++- ‚úÖ Single clock domain
++- ‚úÖ Fully synthesizable for GF180MCU
++
++## Author
++
++**Rakesh Peter**
++
++## License
++
++Apache-2.0
++
++## Acknowledgments
++
++Based on the iCEstick-hacks FM transmitter project, adapted for TinyTapeout and GF180MCU ASIC implementation.
++
++---
++
++## What is Tiny Tapeout?
++
++Tiny Tapeout is an educational project that aims to make it easier and cheaper than ever to get your digital and analog designs manufactured on a real chip.
++
++To learn more and get started, visit https://tinytapeout.com.
+ 
+ ## Resources
+ 
+@@ -33,9 +131,8 @@ The GitHub action will automatically build the ASIC files using [LibreLane](http
+ 
+ ## What next?
+ 
+-- [Submit your design to the next shuttle](https://app.tinytapeout.com/).
+-- Edit [this README](README.md) and explain your design, how it works, and how to test it.
+-- Share your project on your social network of choice:
++- [Submit your design to the next shuttle](https://app.tinytapeout.com/)
++- Share your project on social media:
+   - LinkedIn [#tinytapeout](https://www.linkedin.com/search/results/content/?keywords=%23tinytapeout) [@TinyTapeout](https://www.linkedin.com/company/100708654/)
+   - Mastodon [#tinytapeout](https://chaos.social/tags/tinytapeout) [@matthewvenn](https://chaos.social/@matthewvenn)
+   - X (formerly Twitter) [#tinytapeout](https://twitter.com/hashtag/tinytapeout) [@tinytapeout](https://twitter.com/tinytapeout)
+diff --git a/docs/info.md b/docs/info.md
+index ce1f04c..1a0c5bc 100644
+--- a/docs/info.md
++++ b/docs/info.md
+@@ -9,12 +9,81 @@ You can also include images in this folder and reference them in the markdown. E
+ 
+ ## How it works
+ 
+-Explain how your project works
++This project is an FM transmitter with musical tone generation using Direct Digital Synthesis (DDS). It plays a 16-note C-major scale pattern via FM modulation. The design has been optimized for efficient ASIC implementation.
++
++### Core Components
++
++**Direct Digital Synthesis (DDS)**: Uses a 32-bit phase accumulator that increments each clock cycle. The MSB toggles at the desired output frequency, creating square wave tones with precise frequency control.
++
++**Melody Generation**: A ROM stores 16 notes of a C-major scale with duration information. The melody sequencer reads notes sequentially, calculates appropriate frequencies, and drives both the audio and FM modulators.
++
++**FM Modulation**: Audio tones modulate the carrier frequency by adjusting the phase increment of the FM modulator. This creates frequency deviation around a ~12.5 MHz center carrier frequency.
++
++**Audio Generator**: Creates audio-frequency square wave output directly from the note frequencies, suitable for driving speakers or buzzers.
++
++**Sequencer**: Controls note timing and progression through the melody, with support for looping playback.
++
++The design outputs both the FM-modulated RF signal and a direct audio-frequency square wave for speakers or debugging.
+ 
+ ## How to test
+ 
+-Explain how to use your project
++### Basic Melody Playback
++
++1. Set `enable` (ui[0]) high to start playback
++2. Set `loop` (ui[1]) high for continuous playback
++3. Monitor `fm_out` (uo[0]) for the FM modulated RF signal
++4. Monitor `audio_out` (uo[1]) for audio frequency output (connect to speaker/buzzer)
++5. Observe `playing` (uo[2]) status - should go high when melody is active
++
++### Status Monitoring
++
++- `playing` (uo[2]): High when melody is active
++- `melody_end` (uo[3]): Pulses at the end of each melody cycle
++- `status[3:0]` (uo[7:4]): Additional status information
++- `bidir_out[7:0]` (uio[7:0]): Bidirectional output pins (configured as outputs)
++
++### Expected Behavior
++
++- When enabled without loop: Plays the 16-note C-major scale once and stops
++- When enabled with loop: Plays the C-major scale continuously
++- FM carrier operates at ~12.5 MHz
++- Audio output provides direct tone generation for speaker/buzzer
+ 
+ ## External hardware
+ 
+-List external hardware used in your project (e.g. PMOD, LED display, etc), if any
++### Optional External Hardware
++
++1. **FM Receiver**: To receive and demodulate the FM signal from `fm_out`
++   - Tune to approximately 12.5 MHz
++   - May require amplification and antenna for best results
++
++2. **Speaker/Buzzer**: Connect to `audio_out` for direct audio playback
++   - Small piezo buzzer or 8Œ© speaker with suitable driver
++   - Output is a square wave at audio frequencies (C4-C5 range)
++
++3. **Oscilloscope** (recommended for testing):
++   - Monitor FM carrier on `fm_out`
++   - Observe audio waveforms on `audio_out`
++   - Measure signal characteristics
++
++### No External Hardware Required
++
++The design is fully functional without any external hardware:
++- Internal melody plays automatically when enabled
++- All signals can be monitored on output pins
++- Self-contained demonstration of FM modulation and DDS principles
++
++### Pin Connections Summary
++
++| Pin | Name | Direction | Description |
++|-----|------|-----------|-------------|
++| ui[0] | enable | Input | Enable playback |
++| ui[1] | loop | Input | Loop melody continuously |
++| ui[2] | - | Input | Unused |
++| ui[3] | - | Input | Unused |
++| uo[0] | fm_out | Output | FM modulated RF output |
++| uo[1] | audio_out | Output | Audio frequency output |
++| uo[2] | playing | Output | Melody playing status |
++| uo[3] | melody_end | Output | End of melody pulse |
++| uo[7:4] | status | Output | Status bits |
++| uio[7:0] | bidir_out | Output | Bidirectional outputs |
+diff --git a/info.yaml b/info.yaml
+index 75edd84..da3d97a 100644
+--- a/info.yaml
++++ b/info.yaml
+@@ -1,14 +1,14 @@
+ # Tiny Tapeout project information
+ project:
+   title:        "Audio Tone Generator & FM Transmitter"
+-  author:       "r4d10n (amply supported by Claude Code :)"
++  author:       "Rakesh Peter"
+   discord:      ""
+-  description:  "FM transmitter with audio tone generation and melody playback via DDS"
++  description:  "Simplified FM transmitter with C-major scale tone generation via DDS"
+   language:     "Verilog"
+   clock_hz:     50000000  # 50 MHz
+ 
+   # How many tiles your design occupies? A single tile is about 340x160 uM.
+-  tiles: "1x1"
++  tiles: "1x2"
+ 
+   # Your top module name must start with "tt_um_". Make it unique by including your github username:
+   top_module:  "tt_um_tone_fm_tx"
+@@ -23,8 +23,6 @@ project:
+     - "melody_sequencer.v"
+     - "fm_modulator.v"
+     - "audio_tone_generator.v"
+-    - "clock_doubler.v"
+-    - "pwm_input_decoder.v"
+ 
+ # The pinout of your project. Leave unused pins blank. DO NOT delete or add any pins.
+ # This section is for the datasheet/website. Use descriptive names (e.g., RX, TX, MOSI, SCL, SEG_A, etc.).
+@@ -32,8 +30,8 @@ pinout:
+   # Inputs
+   ui[0]: "enable"
+   ui[1]: "loop"
+-  ui[2]: "clk_2x_enable"
+-  ui[3]: "pwm_in"
++  ui[2]: ""
++  ui[3]: ""
+   ui[4]: ""
+   ui[5]: ""
+   ui[6]: ""
+@@ -44,20 +42,20 @@ pinout:
+   uo[1]: "audio_out"
+   uo[2]: "playing"
+   uo[3]: "melody_end"
+-  uo[4]: "note_index[0]"
+-  uo[5]: "note_index[1]"
+-  uo[6]: "note_index[2]"
+-  uo[7]: "note_index[3]"
++  uo[4]: "status[0]"
++  uo[5]: "status[1]"
++  uo[6]: "status[2]"
++  uo[7]: "status[3]"
+ 
+   # Bidirectional pins
+-  uio[0]: "phase_inc[24]"
+-  uio[1]: "phase_inc[25]"
+-  uio[2]: "phase_inc[26]"
+-  uio[3]: "phase_inc[27]"
+-  uio[4]: "phase_inc[28]"
+-  uio[5]: "phase_inc[29]"
+-  uio[6]: "phase_inc[30]"
+-  uio[7]: "phase_inc[31]"
++  uio[0]: "bidir_out[0]"
++  uio[1]: "bidir_out[1]"
++  uio[2]: "bidir_out[2]"
++  uio[3]: "bidir_out[3]"
++  uio[4]: "bidir_out[4]"
++  uio[5]: "bidir_out[5]"
++  uio[6]: "bidir_out[6]"
++  uio[7]: "bidir_out[7]"
+ 
+ # Do not change!
+ yaml_version: 6
+diff --git a/src/audio_tone_generator.v b/src/audio_tone_generator.v
+index 2b0d86a..dde6e4a 100644
+--- a/src/audio_tone_generator.v
++++ b/src/audio_tone_generator.v
+@@ -72,39 +72,21 @@ module audio_tone_generator #(
+     // Pre-calculated multipliers for semitone offsets
+     // Multiplier = 2^(semitone/12) * 65536 (fixed-point 16.16)
+     //
+-    // This avoids runtime exponential calculation
++    // Simplified to only include C4-C5 range (-9 to +3) to reduce area
+ 
+     function [31:0] semitone_multiplier;
+         input signed [7:0] semitone;
+         begin
+-            // Lookup table for semitone multipliers (√ó65536 fixed point)
+-            // Only cover the range we need for F√ºr Elise (-9 to +12)
++            // Reduced lookup table for C-major scale only
+             case (semitone)
+-                -8'd12: semitone_multiplier = 32768;   // 0.5√ó
+-                -8'd11: semitone_multiplier = 34716;   // 2^(-11/12)
+-                -8'd10: semitone_multiplier = 36781;   // 2^(-10/12)
+-                -8'd9:  semitone_multiplier = 38968;   // C4: 2^(-9/12) = 0.5946
+-                -8'd8:  semitone_multiplier = 41285;   // C#4
++                -8'd9:  semitone_multiplier = 38968;   // C4
+                 -8'd7:  semitone_multiplier = 43740;   // D4
+-                -8'd6:  semitone_multiplier = 46341;   // D#4
+                 -8'd5:  semitone_multiplier = 49097;   // E4
+                 -8'd4:  semitone_multiplier = 52016;   // F4
+-                -8'd3:  semitone_multiplier = 55109;   // F#4
+                 -8'd2:  semitone_multiplier = 58386;   // G4
+-                -8'd1:  semitone_multiplier = 61858;   // G#4
+-                8'd0:   semitone_multiplier = 65536;   // A4: 1.0√ó
+-                8'd1:   semitone_multiplier = 69433;   // A#4
++                8'd0:   semitone_multiplier = 65536;   // A4
+                 8'd2:   semitone_multiplier = 73562;   // B4
+                 8'd3:   semitone_multiplier = 77936;   // C5
+-                8'd4:   semitone_multiplier = 82570;   // C#5
+-                8'd5:   semitone_multiplier = 87480;   // D5
+-                8'd6:   semitone_multiplier = 92682;   // D#5
+-                8'd7:   semitone_multiplier = 98193;   // E5
+-                8'd8:   semitone_multiplier = 104032;  // F5
+-                8'd9:   semitone_multiplier = 110218;  // F#5
+-                8'd10:  semitone_multiplier = 116772;  // G5
+-                8'd11:  semitone_multiplier = 123715;  // G#5
+-                8'd12:  semitone_multiplier = 131072;  // A5: 2.0√ó
+                 default: semitone_multiplier = 65536;  // Default to A4
+             endcase
+         end
+diff --git a/src/fur_elise_fm_top.v b/src/fur_elise_fm_top.v
+index 830d2a5..942e0ac 100644
+--- a/src/fur_elise_fm_top.v
++++ b/src/fur_elise_fm_top.v
+@@ -2,38 +2,22 @@
+ // Module: fur_elise_fm_top
+ //
+ // Description:
+-//   Top-level module for the F√ºr Elise FM transmitter with PWM audio input
+-//   capability and optional clock doubling.
++//   Simplified FM transmitter with musical tone generation.
++//   Plays a simple C-major scale pattern via FM modulation.
++//   Optimized for reduced ASIC area.
+ //
+ // Features:
+-//   - Plays built-in F√ºr Elise melody via FM
+-//   - Accepts external PWM audio input for FM transmission
+-//   - Optional clock doubling (XOR-based) for higher FM carrier frequency
++//   - Plays built-in C-major scale melody via FM
+ //   - Audio frequency output for direct speaker connection
+ //   - Phase increment output for debugging/monitoring
+ //
+-// Operating Modes:
+-//   1. Melody Mode (pwm_in tied low or floating):
+-//      - Plays F√ºr Elise from internal ROM
+-//      - FM output modulated with musical notes
+-//
+-//   2. PWM Input Mode (pwm_in connected to external source):
+-//      - External PWM audio is decoded and transmitted via FM
+-//      - Melody playback continues on audio_out
+-//
+-// Clock Doubling:
+-//   - Enabled via clk_2x_enable jumper
+-//   - Uses XOR-based edge detection to double clock frequency
+-//   - Doubles FM carrier frequency (e.g., 100MHz ‚Üí ~200MHz effective)
+-//   - Useful for reaching higher carrier frequencies without PLL
+-//
+ // Ports:
+-//   clk           - Input clock (~100 MHz expected)
++//   clk           - Input clock (~50 MHz expected)
+ //   rst_n         - Active-low reset
+ //   enable        - Enable playback
+ //   loop          - Loop melody continuously
+-//   clk_2x_enable - Enable clock doubling (jumper)
+-//   pwm_in        - External PWM audio input
++//   clk_2x_enable - Reserved (unused)
++//   pwm_in        - Reserved (unused)
+ //   fm_out        - FM modulated RF output
+ //   audio_out     - Audio frequency output (speaker)
+ //   phase_inc_out - Current phase increment (32-bit, for debugging)
+@@ -80,8 +64,8 @@ module fur_elise_fm_top #(
+     //-------------------------------------------------------------------------
+     // Melody Parameters
+     //-------------------------------------------------------------------------
+-    parameter MELODY_LENGTH = 82,
+-    parameter ADDR_WIDTH    = 7
++    parameter MELODY_LENGTH = 16,
++    parameter ADDR_WIDTH    = 5
+ )(
+     //-------------------------------------------------------------------------
+     // Clock and Reset
+@@ -117,41 +101,9 @@ module fur_elise_fm_top #(
+ );
+ 
+     //=========================================================================
+-    // Clock Doubling
+-    //=========================================================================
+-
+-    wire clk_fast;  // Potentially doubled clock
+-
+-    clock_doubler #(
+-        .DELAY_STAGES(8)
+-    ) u_clk_doubler (
+-        .clk_in  (clk),
+-        .enable  (clk_2x_enable),
+-        .clk_out (clk_fast)
+-    );
+-
+-    //=========================================================================
+-    // PWM Input Decoder
++    // Simplified Design - PWM and clock doubler removed for area optimization
+     //=========================================================================
+ 
+-    wire signed [15:0] pwm_sample;
+-    wire pwm_sample_valid;
+-    wire [15:0] pwm_debug;
+-
+-    pwm_input_decoder #(
+-        .CLK_FREQ_HZ(CLK_FREQ_HZ),
+-        .PWM_FREQ_HZ(PWM_FREQ_HZ),
+-        .SAMPLE_BITS(16)
+-    ) u_pwm_decoder (
+-        .clk         (clk),
+-        .rst_n       (rst_n),
+-        .enable      (enable),
+-        .pwm_in      (pwm_in),
+-        .sample_out  (pwm_sample),
+-        .sample_valid(pwm_sample_valid),
+-        .debug_count (pwm_debug)
+-    );
+-
+     //=========================================================================
+     // Melody ROM and Sequencer
+     //=========================================================================
+@@ -209,63 +161,11 @@ module fur_elise_fm_top #(
+         .is_rest         (melody_is_rest)
+     );
+ 
+-    //=========================================================================
+-    // PWM to Phase Increment Conversion
+-    //=========================================================================
+-    // Convert PWM sample to FM deviation
+-    // phase_increment = BASE_PHASE_INCREMENT + (pwm_sample * PWM_DEVIATION_SCALE)
+-
+-    reg [31:0] pwm_phase_increment;
+-    reg pwm_active;
+-
+-    // Detect if PWM input is active (has valid samples)
+-    reg [7:0] pwm_timeout_counter;
+-    localparam PWM_TIMEOUT = 255;
+-
+-    always @(posedge clk or negedge rst_n) begin
+-        if (!rst_n) begin
+-            pwm_timeout_counter <= 0;
+-            pwm_active <= 1'b0;
+-        end else begin
+-            if (pwm_sample_valid) begin
+-                pwm_timeout_counter <= PWM_TIMEOUT;
+-                pwm_active <= 1'b1;
+-            end else if (pwm_timeout_counter > 0) begin
+-                pwm_timeout_counter <= pwm_timeout_counter - 1;
+-            end else begin
+-                pwm_active <= 1'b0;
+-            end
+-        end
+-    end
+-
+-    // Calculate PWM-based phase increment
+-    wire signed [47:0] pwm_deviation;
+-    assign pwm_deviation = $signed(pwm_sample) * $signed({1'b0, PWM_DEVIATION_SCALE});
+-
+-    wire [31:0] pwm_phase_calc;
+-    assign pwm_phase_calc = BASE_PHASE_INCREMENT + pwm_deviation[47:16];
+-
+-    always @(posedge clk or negedge rst_n) begin
+-        if (!rst_n) begin
+-            pwm_phase_increment <= BASE_PHASE_INCREMENT;
+-        end else if (pwm_sample_valid) begin
+-            pwm_phase_increment <= pwm_phase_calc;
+-        end
+-    end
+-
+-    //=========================================================================
+-    // Phase Increment Selection
+-    //=========================================================================
+-    // Use PWM input when active, otherwise use melody
+-
+-    wire [31:0] selected_phase_increment;
+-    assign selected_phase_increment = pwm_active ? pwm_phase_increment : melody_phase_increment;
+-
+     // Output phase increment for debugging/monitoring
+-    assign phase_inc_out = selected_phase_increment;
++    assign phase_inc_out = melody_phase_increment;
+ 
+     //=========================================================================
+-    // FM Modulator (using fast clock)
++    // FM Modulator
+     //=========================================================================
+ 
+     wire fm_raw_out;
+@@ -273,10 +173,10 @@ module fur_elise_fm_top #(
+     fm_modulator #(
+         .ACCUMULATOR_WIDTH(32)
+     ) u_fm_mod (
+-        .clk             (clk_fast),          // Use doubled clock when enabled
++        .clk             (clk),
+         .rst_n           (rst_n),
+-        .enable          (enable & (pitch_valid | pwm_active)),
+-        .phase_increment (selected_phase_increment),
++        .enable          (enable & pitch_valid),
++        .phase_increment (melody_phase_increment),
+         .fm_out          (fm_raw_out),
+         .phase_out       ()
+     );
+@@ -286,7 +186,6 @@ module fur_elise_fm_top #(
+     //=========================================================================
+     // Audio Tone Generator (for speaker output)
+     //=========================================================================
+-    // Always plays melody regardless of PWM input
+ 
+     audio_tone_generator #(
+         .CLK_FREQ_HZ(CLK_FREQ_HZ),
+diff --git a/src/melody_rom.v b/src/melody_rom.v
+index 605fe91..d9027bb 100644
+--- a/src/melody_rom.v
++++ b/src/melody_rom.v
+@@ -80,132 +80,30 @@ module melody_rom #(
+     endfunction
+ 
+     //-------------------------------------------------------------------------
+-    // Melody ROM - F√ºr Elise (Opening Theme)
+-    // The famous A-section repeated, with some of B-section
++    // Melody ROM - Simple C-Major Scale Pattern (16 notes)
++    // Simplified to reduce area utilization for ASIC build
+     //-------------------------------------------------------------------------
+     always @(posedge clk) begin
+         case (addr)
+             //=================================================================
+-            // A Section - First phrase (bars 1-4)
+-            // E5 D#5 E5 D#5 E5 B4 D5 C5 A4
+-            //=================================================================
+-            7'd0:  data <= note(E5,   DUR_8TH);      // E5
+-            7'd1:  data <= note(Ds5,  DUR_8TH);      // D#5
+-            7'd2:  data <= note(E5,   DUR_8TH);      // E5
+-            7'd3:  data <= note(Ds5,  DUR_8TH);      // D#5
+-            7'd4:  data <= note(E5,   DUR_8TH);      // E5
+-            7'd5:  data <= note(B4,   DUR_8TH);      // B4
+-            7'd6:  data <= note(D5,   DUR_8TH);      // D5
+-            7'd7:  data <= note(C5,   DUR_8TH);      // C5
+-            7'd8:  data <= note(A4,   DUR_QUARTER);  // A4 (longer)
+-            7'd9:  data <= note(REST, DUR_8TH);      // Rest
+-
+-            //=================================================================
+-            // A Section - Second phrase (bars 5-8)
+-            // C4 E4 A4 B4 (rest) E4 G#4 B4 C5
+-            //=================================================================
+-            7'd10: data <= note(C4,   DUR_8TH);      // C4
+-            7'd11: data <= note(E4,   DUR_8TH);      // E4
+-            7'd12: data <= note(A4,   DUR_8TH);      // A4
+-            7'd13: data <= note(B4,   DUR_QUARTER);  // B4 (longer)
+-            7'd14: data <= note(REST, DUR_8TH);      // Rest
+-            7'd15: data <= note(E4,   DUR_8TH);      // E4
+-            7'd16: data <= note(Gs4,  DUR_8TH);      // G#4
+-            7'd17: data <= note(B4,   DUR_8TH);      // B4
+-            7'd18: data <= note(C5,   DUR_QUARTER);  // C5 (longer)
+-            7'd19: data <= note(REST, DUR_8TH);      // Rest
+-
+-            //=================================================================
+-            // A Section - Third phrase (bars 9-12) - repeat of first
+-            // E4 E5 D#5 E5 D#5 E5 B4 D5 C5 A4
+-            //=================================================================
+-            7'd20: data <= note(E4,   DUR_8TH);      // E4
+-            7'd21: data <= note(E5,   DUR_8TH);      // E5
+-            7'd22: data <= note(Ds5,  DUR_8TH);      // D#5
+-            7'd23: data <= note(E5,   DUR_8TH);      // E5
+-            7'd24: data <= note(Ds5,  DUR_8TH);      // D#5
+-            7'd25: data <= note(E5,   DUR_8TH);      // E5
+-            7'd26: data <= note(B4,   DUR_8TH);      // B4
+-            7'd27: data <= note(D5,   DUR_8TH);      // D5
+-            7'd28: data <= note(C5,   DUR_8TH);      // C5
+-            7'd29: data <= note(A4,   DUR_QUARTER);  // A4 (longer)
+-            7'd30: data <= note(REST, DUR_8TH);      // Rest
+-
+-            //=================================================================
+-            // A Section - Fourth phrase (bars 13-16)
+-            // C4 E4 A4 B4 (rest) E4 C5 B4 A4
+-            //=================================================================
+-            7'd31: data <= note(C4,   DUR_8TH);      // C4
+-            7'd32: data <= note(E4,   DUR_8TH);      // E4
+-            7'd33: data <= note(A4,   DUR_8TH);      // A4
+-            7'd34: data <= note(B4,   DUR_QUARTER);  // B4 (longer)
+-            7'd35: data <= note(REST, DUR_8TH);      // Rest
+-            7'd36: data <= note(E4,   DUR_8TH);      // E4
+-            7'd37: data <= note(C5,   DUR_8TH);      // C5
+-            7'd38: data <= note(B4,   DUR_8TH);      // B4
+-            7'd39: data <= note(A4,   DUR_HALF);     // A4 (end of A section)
+-            7'd40: data <= note(REST, DUR_QUARTER);  // Rest
+-
+-            //=================================================================
+-            // A Section Repeat - First phrase again
+-            //=================================================================
+-            7'd41: data <= note(E5,   DUR_8TH);      // E5
+-            7'd42: data <= note(Ds5,  DUR_8TH);      // D#5
+-            7'd43: data <= note(E5,   DUR_8TH);      // E5
+-            7'd44: data <= note(Ds5,  DUR_8TH);      // D#5
+-            7'd45: data <= note(E5,   DUR_8TH);      // E5
+-            7'd46: data <= note(B4,   DUR_8TH);      // B4
+-            7'd47: data <= note(D5,   DUR_8TH);      // D5
+-            7'd48: data <= note(C5,   DUR_8TH);      // C5
+-            7'd49: data <= note(A4,   DUR_QUARTER);  // A4
+-            7'd50: data <= note(REST, DUR_8TH);      // Rest
+-
+-            //=================================================================
+-            // A Section Repeat - Second phrase
+-            //=================================================================
+-            7'd51: data <= note(C4,   DUR_8TH);      // C4
+-            7'd52: data <= note(E4,   DUR_8TH);      // E4
+-            7'd53: data <= note(A4,   DUR_8TH);      // A4
+-            7'd54: data <= note(B4,   DUR_QUARTER);  // B4
+-            7'd55: data <= note(REST, DUR_8TH);      // Rest
+-            7'd56: data <= note(E4,   DUR_8TH);      // E4
+-            7'd57: data <= note(Gs4,  DUR_8TH);      // G#4
+-            7'd58: data <= note(B4,   DUR_8TH);      // B4
+-            7'd59: data <= note(C5,   DUR_QUARTER);  // C5
+-            7'd60: data <= note(REST, DUR_8TH);      // Rest
+-
+-            //=================================================================
+-            // A Section Repeat - Third phrase
+-            //=================================================================
+-            7'd61: data <= note(E4,   DUR_8TH);      // E4
+-            7'd62: data <= note(E5,   DUR_8TH);      // E5
+-            7'd63: data <= note(Ds5,  DUR_8TH);      // D#5
+-            7'd64: data <= note(E5,   DUR_8TH);      // E5
+-            7'd65: data <= note(Ds5,  DUR_8TH);      // D#5
+-            7'd66: data <= note(E5,   DUR_8TH);      // E5
+-            7'd67: data <= note(B4,   DUR_8TH);      // B4
+-            7'd68: data <= note(D5,   DUR_8TH);      // D5
+-            7'd69: data <= note(C5,   DUR_8TH);      // C5
+-            7'd70: data <= note(A4,   DUR_QUARTER);  // A4
+-            7'd71: data <= note(REST, DUR_8TH);      // Rest
+-
+-            //=================================================================
+-            // A Section Repeat - Fourth phrase (ending)
+-            //=================================================================
+-            7'd72: data <= note(C4,   DUR_8TH);      // C4
+-            7'd73: data <= note(E4,   DUR_8TH);      // E4
+-            7'd74: data <= note(A4,   DUR_8TH);      // A4
+-            7'd75: data <= note(B4,   DUR_QUARTER);  // B4
+-            7'd76: data <= note(REST, DUR_8TH);      // Rest
+-            7'd77: data <= note(E4,   DUR_8TH);      // E4
+-            7'd78: data <= note(C5,   DUR_8TH);      // C5
+-            7'd79: data <= note(B4,   DUR_8TH);      // B4
+-            7'd80: data <= note(A4,   DUR_WHOLE);    // A4 (final note)
+-
+-            //=================================================================
+-            // End marker and padding
+-            //=================================================================
+-            7'd81: data <= note(REST, DUR_WHOLE);    // Final rest
++            // Simple ascending and descending C-major scale pattern
++            //=================================================================
++            7'd0:  data <= note(C4,   DUR_8TH);      // C4
++            7'd1:  data <= note(D4,   DUR_8TH);      // D4
++            7'd2:  data <= note(E4,   DUR_8TH);      // E4
++            7'd3:  data <= note(F4,   DUR_8TH);      // F4
++            7'd4:  data <= note(G4,   DUR_8TH);      // G4
++            7'd5:  data <= note(A4,   DUR_8TH);      // A4
++            7'd6:  data <= note(B4,   DUR_8TH);      // B4
++            7'd7:  data <= note(C5,   DUR_8TH);      // C5 (octave up)
++            7'd8:  data <= note(C5,   DUR_8TH);      // C5
++            7'd9:  data <= note(B4,   DUR_8TH);      // B4
++            7'd10: data <= note(A4,   DUR_8TH);      // A4
++            7'd11: data <= note(G4,   DUR_8TH);      // G4
++            7'd12: data <= note(F4,   DUR_8TH);      // F4
++            7'd13: data <= note(E4,   DUR_8TH);      // E4
++            7'd14: data <= note(D4,   DUR_8TH);      // D4
++            7'd15: data <= note(C4,   DUR_QUARTER);  // C4 (longer ending)
+ 
+             // Padding with rests for remaining addresses
+             default: data <= note(REST, DUR_QUARTER);
+@@ -215,6 +113,6 @@ module melody_rom #(
+     //-------------------------------------------------------------------------
+     // Melody length output for sequencer
+     //-------------------------------------------------------------------------
+-    // The actual melody ends at address 81 (82 notes total)
++    // The actual melody ends at address 15 (16 notes total)
+ 
+ endmodule
+diff --git a/src/project.v b/src/project.v
+index 9274509..8fae31c 100644
+--- a/src/project.v
++++ b/src/project.v
+@@ -9,23 +9,24 @@
+ // Module: tt_um_tone_fm_tx
+ //
+ // Description:
+-//   TinyTapeout wrapper for audio tone generator and FM transmitter.
+-//   Plays musical melodies via FM modulation with DDS.
++//   TinyTapeout wrapper for simplified FM transmitter.
++//   Plays a C-major scale pattern via FM modulation.
++//   Optimized for reduced ASIC area.
+ //
+ // Pin Mapping:
+ //   ui_in[0]   = enable      - Enable playback
+ //   ui_in[1]   = loop        - Loop melody continuously
+-//   ui_in[2]   = clk_2x_en   - Enable clock doubling
+-//   ui_in[3]   = pwm_in      - External PWM audio input
++//   ui_in[2]   = reserved    - (unused)
++//   ui_in[3]   = reserved    - (unused)
+ //   ui_in[7:4] = reserved
+ //
+ //   uo_out[0]  = fm_out      - FM modulated RF output
+ //   uo_out[1]  = audio_out   - Audio frequency output (speaker)
+ //   uo_out[2]  = playing     - Melody currently playing
+ //   uo_out[3]  = melody_end  - Pulse at end of melody
+-//   uo_out[7:4]= note_index[3:0] - Current note index (debug)
++//   uo_out[7:4]= status      - Status bits
+ //
+-//   uio[7:0]   = phase_inc[31:24] - Phase increment MSB (output mode)
++//   uio[7:0]   = outputs     - Bidirectional I/O (configured as outputs)
+ //
+ //-----------------------------------------------------------------------------
+ 
+@@ -45,8 +46,7 @@ module tt_um_tone_fm_tx (
+     //=========================================================================
+     wire enable      = ui_in[0] & ena;
+     wire loop        = ui_in[1];
+-    wire clk_2x_en   = ui_in[2];
+-    wire pwm_in      = ui_in[3];
++    // ui_in[2] and ui_in[3] reserved (unused)
+ 
+     //=========================================================================
+     // Internal Signals
+@@ -56,23 +56,23 @@ module tt_um_tone_fm_tx (
+     wire [31:0] phase_inc_out;
+     wire        playing;
+     wire        melody_end;
+-    wire [6:0]  note_index;
++    wire [4:0]  note_index;
+ 
+     //=========================================================================
+-    // FM Transmitter Core
++    // FM Transmitter Core (Simplified)
+     //=========================================================================
+     fur_elise_fm_top #(
+         .CLK_FREQ_HZ(50_000_000),           // TinyTapeout clock is ~50 MHz
+         .CLOCKS_PER_16TH(50_000_000 / 8),   // 120 BPM
+-        .MELODY_LENGTH(82),
++        .MELODY_LENGTH(16),                 // Simplified 16-note melody
+         .PWM_FREQ_HZ(50_000)
+     ) u_fur_elise (
+         .clk           (clk),
+         .rst_n         (rst_n),
+         .enable        (enable),
+         .loop          (loop),
+-        .clk_2x_enable (clk_2x_en),
+-        .pwm_in        (pwm_in),
++        .clk_2x_enable (1'b0),              // Disabled
++        .pwm_in        (1'b0),              // Disabled
+         .fm_out        (fm_out),
+         .audio_out     (audio_out),
+         .phase_inc_out (phase_inc_out),
+@@ -95,6 +95,6 @@ module tt_um_tone_fm_tx (
+     assign uio_oe  = 8'hFF;  // All outputs
+ 
+     // Suppress unused input warnings
+-    wire _unused = &{uio_in, note_index[6:4], 1'b0};
++    wire _unused = &{uio_in, ui_in[7:2], note_index[4], 1'b0};
+ 
+ endmodule
+diff --git a/test/Makefile b/test/Makefile
+index eccc91c..a6cd3b1 100644
+--- a/test/Makefile
++++ b/test/Makefile
+@@ -1,25 +1,44 @@
+-# TinyTapeout Fur Elise FM Testbench Makefile
++# Makefile
++# See https://docs.cocotb.org/en/stable/quickstart.html for more info
+ 
+-IVERILOG = iverilog
+-VVP = vvp
+-GTKWAVE = gtkwave
++# defaults
++SIM ?= icarus
++TOPLEVEL_LANG ?= verilog
++SRC_DIR = $(PWD)/../src
++PROJECT_SOURCES = project.v fur_elise_fm_top.v melody_rom.v melody_sequencer.v fm_modulator.v audio_tone_generator.v
+ 
+-SRC_DIR = ../src
+-TB = tb.v
+-SRC_FILES = $(wildcard $(SRC_DIR)/*.v)
++ifneq ($(GATES),yes)
+ 
+-all: sim
++# RTL simulation:
++SIM_BUILD				= sim_build/rtl
++VERILOG_SOURCES += $(addprefix $(SRC_DIR)/,$(PROJECT_SOURCES))
+ 
+-sim: tb
+-	$(VVP) tb
++else
+ 
+-tb: $(TB) $(SRC_FILES)
+-	$(IVERILOG) -o tb $(TB) $(SRC_FILES)
++# Gate level simulation:
++SIM_BUILD				= sim_build/gl
++COMPILE_ARGS    += -DGL_TEST
++COMPILE_ARGS    += -DFUNCTIONAL
++COMPILE_ARGS    += -DUSE_POWER_PINS
++COMPILE_ARGS    += -DSIM
++COMPILE_ARGS    += -DUNIT_DELAY=\#1
++VERILOG_SOURCES += $(PDK_ROOT)/gf180mcuD/libs.ref/gf180mcu_fd_sc_mcu7t5v0/verilog/primitives.v
++VERILOG_SOURCES += $(PDK_ROOT)/gf180mcuD/libs.ref/gf180mcu_fd_sc_mcu7t5v0/verilog/gf180mcu_fd_sc_mcu7t5v0.v
+ 
+-wave: sim
+-	$(GTKWAVE) tb.vcd &
++# this gets copied in by the GDS action workflow
++VERILOG_SOURCES += $(PWD)/gate_level_netlist.v
+ 
+-clean:
+-	rm -f tb tb.vcd
++endif
+ 
+-.PHONY: all sim wave clean
++# Allow sharing configuration between design and testbench via `include`:
++COMPILE_ARGS 		+= -I$(SRC_DIR)
++
++# Include the testbench sources:
++VERILOG_SOURCES += $(PWD)/tb.v
++TOPLEVEL = tb
++
++# List test modules to run, separated by commas and without the .py suffix:
++COCOTB_TEST_MODULES = test
++
++# include cocotb's make rules to take care of the simulator setup
++include $(shell cocotb-config --makefiles)/Makefile.sim
+diff --git a/test/tb.v b/test/tb.v
+index bf23d86..a3b271f 100644
+--- a/test/tb.v
++++ b/test/tb.v
+@@ -1,253 +1,49 @@
+-/*
+- * Copyright (c) 2024 Your Name
+- * SPDX-License-Identifier: Apache-2.0
+- */
+-
+ `default_nettype none
+ `timescale 1ns / 1ps
+ 
+-//-----------------------------------------------------------------------------
+-// Testbench: tb
+-//
+-// Description:
+-//   TinyTapeout testbench for F√ºr Elise FM transmitter.
+-//
+-// Usage:
+-//   iverilog -o tb tb.v ../src/*.v
+-//   vvp tb
+-//   gtkwave tb.vcd
+-//-----------------------------------------------------------------------------
+-
+-module tb;
+-
+-    //=========================================================================
+-    // Test Parameters
+-    //=========================================================================
+-    localparam CLK_PERIOD_NS = 20;  // 50 MHz clock
+-
+-    //=========================================================================
+-    // DUT Signals
+-    //=========================================================================
+-    reg         clk;
+-    reg         rst_n;
+-    reg         ena;
+-    reg  [7:0]  ui_in;
+-    wire [7:0]  uo_out;
+-    reg  [7:0]  uio_in;
+-    wire [7:0]  uio_out;
+-    wire [7:0]  uio_oe;
+-
+-    //=========================================================================
+-    // DUT Instantiation
+-    //=========================================================================
+-    tt_um_tone_fm_tx dut (
+-        .ui_in   (ui_in),
+-        .uo_out  (uo_out),
+-        .uio_in  (uio_in),
+-        .uio_out (uio_out),
+-        .uio_oe  (uio_oe),
+-        .ena     (ena),
+-        .clk     (clk),
+-        .rst_n   (rst_n)
+-    );
+-
+-    //=========================================================================
+-    // Clock Generation
+-    //=========================================================================
+-    initial clk = 0;
+-    always #(CLK_PERIOD_NS/2) clk = ~clk;
+-
+-    //=========================================================================
+-    // Signal Aliases for Readability
+-    //=========================================================================
+-    wire fm_out     = uo_out[0];
+-    wire audio_out  = uo_out[1];
+-    wire playing    = uo_out[2];
+-    wire melody_end = uo_out[3];
+-    wire [3:0] note_idx = uo_out[7:4];
+-    wire [7:0] phase_msb = uio_out;
+-
+-    //=========================================================================
+-    // Output Monitoring
+-    //=========================================================================
+-    reg fm_out_prev;
+-    integer fm_transitions;
+-
+-    always @(posedge clk) begin
+-        fm_out_prev <= fm_out;
+-        if (fm_out && !fm_out_prev)
+-            fm_transitions <= fm_transitions + 1;
+-    end
+-
+-    //=========================================================================
+-    // Helper Tasks
+-    //=========================================================================
+-    task reset_dut;
+-        begin
+-            rst_n = 0;
+-            ena = 0;
+-            ui_in = 8'h00;
+-            uio_in = 8'h00;
+-            fm_transitions = 0;
+-            #100;
+-            rst_n = 1;
+-            ena = 1;
+-            #100;
+-        end
+-    endtask
+-
+-    task wait_clocks;
+-        input integer num_clocks;
+-        begin
+-            repeat (num_clocks) @(posedge clk);
+-        end
+-    endtask
+-
+-    //=========================================================================
+-    // Test Sequence
+-    //=========================================================================
+-    integer test_passed;
+-
+-    initial begin
+-        $dumpfile("tb.vcd");
+-        $dumpvars(0, tb);
+-
+-        test_passed = 1;
+-
+-        $display("");
+-        $display("================================================");
+-        $display("TinyTapeout Fur Elise FM Testbench");
+-        $display("================================================");
+-        $display("");
+-
+-        //---------------------------------------------------------------------
+-        // Test 1: Reset Behavior
+-        //---------------------------------------------------------------------
+-        $display("[TEST 1] Reset behavior...");
+-        reset_dut();
+-
+-        if (playing !== 0) begin
+-            $display("  FAIL: playing should be 0 after reset (enable=0)");
+-            test_passed = 0;
+-        end else begin
+-            $display("  PASS: Clean reset state");
+-        end
+-
+-        //---------------------------------------------------------------------
+-        // Test 2: Enable Playback
+-        //---------------------------------------------------------------------
+-        $display("[TEST 2] Enable playback...");
+-        reset_dut();
+-        ui_in[0] = 1;  // enable
+-        ui_in[1] = 1;  // loop
+-
+-        wait_clocks(5000);
+-
+-        if (!playing) begin
+-            $display("  FAIL: Should be playing melody");
+-            test_passed = 0;
+-        end else begin
+-            $display("  PASS: Melody playback active");
+-            $display("  Phase MSB: 0x%02X", phase_msb);
+-        end
+-
+-        //---------------------------------------------------------------------
+-        // Test 3: FM Output Activity
+-        //---------------------------------------------------------------------
+-        $display("[TEST 3] FM output activity...");
+-        fm_transitions = 0;
+-        wait_clocks(10000);
+-
+-        if (fm_transitions > 0) begin
+-            $display("  PASS: FM output toggling (%0d transitions)", fm_transitions);
+-        end else begin
+-            $display("  FAIL: No FM output transitions");
+-            test_passed = 0;
+-        end
+-
+-        //---------------------------------------------------------------------
+-        // Test 4: Clock Doubling
+-        //---------------------------------------------------------------------
+-        $display("[TEST 4] Clock doubling...");
+-        reset_dut();
+-        ui_in[0] = 1;  // enable
+-        ui_in[2] = 1;  // clk_2x_enable
+-
+-        fm_transitions = 0;
+-        wait_clocks(10000);
+-        $display("  FM transitions with 2x clock: %0d", fm_transitions);
+-
+-        //---------------------------------------------------------------------
+-        // Test 5: Audio Output
+-        //---------------------------------------------------------------------
+-        $display("[TEST 5] Audio output...");
+-        reset_dut();
+-        ui_in[0] = 1;  // enable
+-
+-        begin : audio_test
+-            integer audio_transitions;
+-            reg audio_prev;
+-            audio_transitions = 0;
+-            audio_prev = 0;
+-
+-            repeat (50000) begin
+-                @(posedge clk);
+-                if (audio_out && !audio_prev)
+-                    audio_transitions = audio_transitions + 1;
+-                audio_prev = audio_out;
+-            end
+-
+-            if (audio_transitions > 0) begin
+-                $display("  PASS: Audio output active (%0d transitions)", audio_transitions);
+-            end else begin
+-                $display("  WARN: No audio transitions detected");
+-            end
+-        end
+-
+-        //---------------------------------------------------------------------
+-        // Test 6: Loop Mode
+-        //---------------------------------------------------------------------
+-        $display("[TEST 6] Loop mode...");
+-        reset_dut();
+-        ui_in[0] = 1;  // enable
+-        ui_in[1] = 1;  // loop
+-
+-        @(posedge melody_end);
+-        $display("  First melody_end detected");
+-
+-        wait_clocks(5000);
+-
+-        if (!playing) begin
+-            $display("  FAIL: Should still be playing in loop mode");
+-            test_passed = 0;
+-        end else begin
+-            $display("  PASS: Loop mode continues playback");
+-        end
+-
+-        //---------------------------------------------------------------------
+-        // Test Summary
+-        //---------------------------------------------------------------------
+-        $display("");
+-        $display("================================================");
+-        if (test_passed) begin
+-            $display("ALL TESTS PASSED");
+-        end else begin
+-            $display("SOME TESTS FAILED");
+-        end
+-        $display("================================================");
+-        $display("");
+-
+-        wait_clocks(1000);
+-        $finish;
+-    end
+-
+-    //=========================================================================
+-    // Timeout Watchdog
+-    //=========================================================================
+-    initial begin
+-        #50_000_000;  // 50ms timeout
+-        $display("TIMEOUT: Simulation took too long");
+-        $finish;
+-    end
++/* This testbench just instantiates the module and makes some convenient wires
++   that can be driven / tested by the cocotb test.py.
++*/
++module tb ();
++
++  // Dump the signals to a VCD file. You can view it with gtkwave or surfer.
++  initial begin
++    $dumpfile("tb.vcd");
++    $dumpvars(0, tb);
++    #1;
++  end
++
++  // Wire up the inputs and outputs:
++  reg clk;
++  reg rst_n;
++  reg ena;
++  reg [7:0] ui_in;
++  reg [7:0] uio_in;
++  wire [7:0] uo_out;
++  wire [7:0] uio_out;
++  wire [7:0] uio_oe;
++`ifdef GL_TEST
++  wire VPWR = 1'b1;
++  wire VGND = 1'b0;
++`endif
++
++  // Replace tt_um_example with your module name:
++  tt_um_tone_fm_tx user_project (
++
++      // Include power ports for the Gate Level test:
++`ifdef GL_TEST
++      .VPWR(VPWR),
++      .VGND(VGND),
++`endif
++
++      .ui_in  (ui_in),    // Dedicated inputs
++      .uo_out (uo_out),   // Dedicated outputs
++      .uio_in (uio_in),   // IOs: Input path
++      .uio_out(uio_out),  // IOs: Output path
++      .uio_oe (uio_oe),   // IOs: Enable path (active high: 0=input, 1=output)
++      .ena    (ena),      // enable - goes high when design is selected
++      .clk    (clk),      // clock
++      .rst_n  (rst_n)     // not reset
++  );
+ 
+ endmodule
+diff --git a/test/test.py b/test/test.py
+index 26592e7..0816c2f 100644
+--- a/test/test.py
++++ b/test/test.py
+@@ -23,18 +23,39 @@ async def test_project(dut):
+     await ClockCycles(dut.clk, 10)
+     dut.rst_n.value = 1
+ 
+-    dut._log.info("Test project behavior")
++    dut._log.info("Test FM transmitter behavior")
+ 
+-    # Set the input values you want to test
+-    dut.ui_in.value = 20
+-    dut.uio_in.value = 30
++    # Enable the FM transmitter and loop mode
++    # ui_in[0] = enable, ui_in[1] = loop
++    dut.ui_in.value = 0b00000011  # Enable and loop
+ 
+-    # Wait for one clock cycle to see the output values
+-    await ClockCycles(dut.clk, 1)
++    # Wait for the module to start
++    await ClockCycles(dut.clk, 10)
+ 
+-    # The following assersion is just an example of how to check the output values.
+-    # Change it to match the actual expected output of your module:
+-    assert dut.uo_out.value == 50
++    # Check that playing signal goes high
++    # uo_out[2] = playing
++    uo_out_val = int(dut.uo_out.value)
++    playing = (uo_out_val >> 2) & 0x1
++    dut._log.info(f"Playing status: {playing}")
++    assert playing == 1, "Module should be playing"
++
++    # Check that we can read note index
++    # uo_out[7:4] = note_index[3:0]
++    note_index = (uo_out_val >> 4) & 0xF
++    dut._log.info(f"Note index: {note_index}")
++
++    # Wait longer and verify the note index advances
++    await ClockCycles(dut.clk, 1000)
++    uo_out_val = int(dut.uo_out.value)
++    note_index_new = (uo_out_val >> 4) & 0xF
++    dut._log.info(f"Note index after wait: {note_index_new}")
++
++    # Disable and check that playing stops
++    dut.ui_in.value = 0b00000000  # Disable
++    await ClockCycles(dut.clk, 10)
++    uo_out_val = int(dut.uo_out.value)
++    playing = (uo_out_val >> 2) & 0x1
++    dut._log.info(f"Playing status after disable: {playing}")
++    assert playing == 0, "Module should not be playing after disable"
+ 
+-    # Keep testing the module by changing the input values, waiting for
+-    # one or more clock cycles, and asserting the expected output values.
++    dut._log.info("Test completed successfully")
diff --git a/src/audio_tone_generator.v b/src/audio_tone_generator.v
index 2b0d86ad6359f3b7d1f4502d722dee9d7dbb247c..dde6e4ac018367b3c84f9b775446d30ada4d9857 100644
--- a/src/audio_tone_generator.v
+++ b/src/audio_tone_generator.v
@@ -72,39 +72,21 @@ module audio_tone_generator #(
     // Pre-calculated multipliers for semitone offsets
     // Multiplier = 2^(semitone/12) * 65536 (fixed-point 16.16)
     //
-    // This avoids runtime exponential calculation
+    // Simplified to only include C4-C5 range (-9 to +3) to reduce area
 
     function [31:0] semitone_multiplier;
         input signed [7:0] semitone;
         begin
-            // Lookup table for semitone multipliers (√ó65536 fixed point)
-            // Only cover the range we need for F√ºr Elise (-9 to +12)
+            // Reduced lookup table for C-major scale only
             case (semitone)
-                -8'd12: semitone_multiplier = 32768;   // 0.5√ó
-                -8'd11: semitone_multiplier = 34716;   // 2^(-11/12)
-                -8'd10: semitone_multiplier = 36781;   // 2^(-10/12)
-                -8'd9:  semitone_multiplier = 38968;   // C4: 2^(-9/12) = 0.5946
-                -8'd8:  semitone_multiplier = 41285;   // C#4
+                -8'd9:  semitone_multiplier = 38968;   // C4
                 -8'd7:  semitone_multiplier = 43740;   // D4
-                -8'd6:  semitone_multiplier = 46341;   // D#4
                 -8'd5:  semitone_multiplier = 49097;   // E4
                 -8'd4:  semitone_multiplier = 52016;   // F4
-                -8'd3:  semitone_multiplier = 55109;   // F#4
                 -8'd2:  semitone_multiplier = 58386;   // G4
-                -8'd1:  semitone_multiplier = 61858;   // G#4
-                8'd0:   semitone_multiplier = 65536;   // A4: 1.0√ó
-                8'd1:   semitone_multiplier = 69433;   // A#4
+                8'd0:   semitone_multiplier = 65536;   // A4
                 8'd2:   semitone_multiplier = 73562;   // B4
                 8'd3:   semitone_multiplier = 77936;   // C5
-                8'd4:   semitone_multiplier = 82570;   // C#5
-                8'd5:   semitone_multiplier = 87480;   // D5
-                8'd6:   semitone_multiplier = 92682;   // D#5
-                8'd7:   semitone_multiplier = 98193;   // E5
-                8'd8:   semitone_multiplier = 104032;  // F5
-                8'd9:   semitone_multiplier = 110218;  // F#5
-                8'd10:  semitone_multiplier = 116772;  // G5
-                8'd11:  semitone_multiplier = 123715;  // G#5
-                8'd12:  semitone_multiplier = 131072;  // A5: 2.0√ó
                 default: semitone_multiplier = 65536;  // Default to A4
             endcase
         end
diff --git a/src/fur_elise_fm_top.v b/src/fur_elise_fm_top.v
index 830d2a5d275bf740c0ff1cd859d0b0e61250250b..942e0acebb5c2c369354fd95b060d7716bdc42f5 100644
--- a/src/fur_elise_fm_top.v
+++ b/src/fur_elise_fm_top.v
@@ -2,38 +2,22 @@
 // Module: fur_elise_fm_top
 //
 // Description:
-//   Top-level module for the F√ºr Elise FM transmitter with PWM audio input
-//   capability and optional clock doubling.
+//   Simplified FM transmitter with musical tone generation.
+//   Plays a simple C-major scale pattern via FM modulation.
+//   Optimized for reduced ASIC area.
 //
 // Features:
-//   - Plays built-in F√ºr Elise melody via FM
-//   - Accepts external PWM audio input for FM transmission
-//   - Optional clock doubling (XOR-based) for higher FM carrier frequency
+//   - Plays built-in C-major scale melody via FM
 //   - Audio frequency output for direct speaker connection
 //   - Phase increment output for debugging/monitoring
 //
-// Operating Modes:
-//   1. Melody Mode (pwm_in tied low or floating):
-//      - Plays F√ºr Elise from internal ROM
-//      - FM output modulated with musical notes
-//
-//   2. PWM Input Mode (pwm_in connected to external source):
-//      - External PWM audio is decoded and transmitted via FM
-//      - Melody playback continues on audio_out
-//
-// Clock Doubling:
-//   - Enabled via clk_2x_enable jumper
-//   - Uses XOR-based edge detection to double clock frequency
-//   - Doubles FM carrier frequency (e.g., 100MHz ‚Üí ~200MHz effective)
-//   - Useful for reaching higher carrier frequencies without PLL
-//
 // Ports:
-//   clk           - Input clock (~100 MHz expected)
+//   clk           - Input clock (~50 MHz expected)
 //   rst_n         - Active-low reset
 //   enable        - Enable playback
 //   loop          - Loop melody continuously
-//   clk_2x_enable - Enable clock doubling (jumper)
-//   pwm_in        - External PWM audio input
+//   clk_2x_enable - Reserved (unused)
+//   pwm_in        - Reserved (unused)
 //   fm_out        - FM modulated RF output
 //   audio_out     - Audio frequency output (speaker)
 //   phase_inc_out - Current phase increment (32-bit, for debugging)
@@ -80,8 +64,8 @@ module fur_elise_fm_top #(
     //-------------------------------------------------------------------------
     // Melody Parameters
     //-------------------------------------------------------------------------
-    parameter MELODY_LENGTH = 82,
-    parameter ADDR_WIDTH    = 7
+    parameter MELODY_LENGTH = 16,
+    parameter ADDR_WIDTH    = 5
 )(
     //-------------------------------------------------------------------------
     // Clock and Reset
@@ -117,41 +101,9 @@ module fur_elise_fm_top #(
 );
 
     //=========================================================================
-    // Clock Doubling
-    //=========================================================================
-
-    wire clk_fast;  // Potentially doubled clock
-
-    clock_doubler #(
-        .DELAY_STAGES(8)
-    ) u_clk_doubler (
-        .clk_in  (clk),
-        .enable  (clk_2x_enable),
-        .clk_out (clk_fast)
-    );
-
-    //=========================================================================
-    // PWM Input Decoder
+    // Simplified Design - PWM and clock doubler removed for area optimization
     //=========================================================================
 
-    wire signed [15:0] pwm_sample;
-    wire pwm_sample_valid;
-    wire [15:0] pwm_debug;
-
-    pwm_input_decoder #(
-        .CLK_FREQ_HZ(CLK_FREQ_HZ),
-        .PWM_FREQ_HZ(PWM_FREQ_HZ),
-        .SAMPLE_BITS(16)
-    ) u_pwm_decoder (
-        .clk         (clk),
-        .rst_n       (rst_n),
-        .enable      (enable),
-        .pwm_in      (pwm_in),
-        .sample_out  (pwm_sample),
-        .sample_valid(pwm_sample_valid),
-        .debug_count (pwm_debug)
-    );
-
     //=========================================================================
     // Melody ROM and Sequencer
     //=========================================================================
@@ -209,63 +161,11 @@ module fur_elise_fm_top #(
         .is_rest         (melody_is_rest)
     );
 
-    //=========================================================================
-    // PWM to Phase Increment Conversion
-    //=========================================================================
-    // Convert PWM sample to FM deviation
-    // phase_increment = BASE_PHASE_INCREMENT + (pwm_sample * PWM_DEVIATION_SCALE)
-
-    reg [31:0] pwm_phase_increment;
-    reg pwm_active;
-
-    // Detect if PWM input is active (has valid samples)
-    reg [7:0] pwm_timeout_counter;
-    localparam PWM_TIMEOUT = 255;
-
-    always @(posedge clk or negedge rst_n) begin
-        if (!rst_n) begin
-            pwm_timeout_counter <= 0;
-            pwm_active <= 1'b0;
-        end else begin
-            if (pwm_sample_valid) begin
-                pwm_timeout_counter <= PWM_TIMEOUT;
-                pwm_active <= 1'b1;
-            end else if (pwm_timeout_counter > 0) begin
-                pwm_timeout_counter <= pwm_timeout_counter - 1;
-            end else begin
-                pwm_active <= 1'b0;
-            end
-        end
-    end
-
-    // Calculate PWM-based phase increment
-    wire signed [47:0] pwm_deviation;
-    assign pwm_deviation = $signed(pwm_sample) * $signed({1'b0, PWM_DEVIATION_SCALE});
-
-    wire [31:0] pwm_phase_calc;
-    assign pwm_phase_calc = BASE_PHASE_INCREMENT + pwm_deviation[47:16];
-
-    always @(posedge clk or negedge rst_n) begin
-        if (!rst_n) begin
-            pwm_phase_increment <= BASE_PHASE_INCREMENT;
-        end else if (pwm_sample_valid) begin
-            pwm_phase_increment <= pwm_phase_calc;
-        end
-    end
-
-    //=========================================================================
-    // Phase Increment Selection
-    //=========================================================================
-    // Use PWM input when active, otherwise use melody
-
-    wire [31:0] selected_phase_increment;
-    assign selected_phase_increment = pwm_active ? pwm_phase_increment : melody_phase_increment;
-
     // Output phase increment for debugging/monitoring
-    assign phase_inc_out = selected_phase_increment;
+    assign phase_inc_out = melody_phase_increment;
 
     //=========================================================================
-    // FM Modulator (using fast clock)
+    // FM Modulator
     //=========================================================================
 
     wire fm_raw_out;
@@ -273,10 +173,10 @@ module fur_elise_fm_top #(
     fm_modulator #(
         .ACCUMULATOR_WIDTH(32)
     ) u_fm_mod (
-        .clk             (clk_fast),          // Use doubled clock when enabled
+        .clk             (clk),
         .rst_n           (rst_n),
-        .enable          (enable & (pitch_valid | pwm_active)),
-        .phase_increment (selected_phase_increment),
+        .enable          (enable & pitch_valid),
+        .phase_increment (melody_phase_increment),
         .fm_out          (fm_raw_out),
         .phase_out       ()
     );
@@ -286,7 +186,6 @@ module fur_elise_fm_top #(
     //=========================================================================
     // Audio Tone Generator (for speaker output)
     //=========================================================================
-    // Always plays melody regardless of PWM input
 
     audio_tone_generator #(
         .CLK_FREQ_HZ(CLK_FREQ_HZ),
diff --git a/src/melody_rom.v b/src/melody_rom.v
index 605fe9111c4ed390174841438cd6a6c364664acf..d9027bbce43bd65ece722ea0bebb0f539be40823 100644
--- a/src/melody_rom.v
+++ b/src/melody_rom.v
@@ -80,132 +80,30 @@ module melody_rom #(
     endfunction
 
     //-------------------------------------------------------------------------
-    // Melody ROM - F√ºr Elise (Opening Theme)
-    // The famous A-section repeated, with some of B-section
+    // Melody ROM - Simple C-Major Scale Pattern (16 notes)
+    // Simplified to reduce area utilization for ASIC build
     //-------------------------------------------------------------------------
     always @(posedge clk) begin
         case (addr)
             //=================================================================
-            // A Section - First phrase (bars 1-4)
-            // E5 D#5 E5 D#5 E5 B4 D5 C5 A4
-            //=================================================================
-            7'd0:  data <= note(E5,   DUR_8TH);      // E5
-            7'd1:  data <= note(Ds5,  DUR_8TH);      // D#5
-            7'd2:  data <= note(E5,   DUR_8TH);      // E5
-            7'd3:  data <= note(Ds5,  DUR_8TH);      // D#5
-            7'd4:  data <= note(E5,   DUR_8TH);      // E5
-            7'd5:  data <= note(B4,   DUR_8TH);      // B4
-            7'd6:  data <= note(D5,   DUR_8TH);      // D5
-            7'd7:  data <= note(C5,   DUR_8TH);      // C5
-            7'd8:  data <= note(A4,   DUR_QUARTER);  // A4 (longer)
-            7'd9:  data <= note(REST, DUR_8TH);      // Rest
-
-            //=================================================================
-            // A Section - Second phrase (bars 5-8)
-            // C4 E4 A4 B4 (rest) E4 G#4 B4 C5
-            //=================================================================
-            7'd10: data <= note(C4,   DUR_8TH);      // C4
-            7'd11: data <= note(E4,   DUR_8TH);      // E4
-            7'd12: data <= note(A4,   DUR_8TH);      // A4
-            7'd13: data <= note(B4,   DUR_QUARTER);  // B4 (longer)
-            7'd14: data <= note(REST, DUR_8TH);      // Rest
-            7'd15: data <= note(E4,   DUR_8TH);      // E4
-            7'd16: data <= note(Gs4,  DUR_8TH);      // G#4
-            7'd17: data <= note(B4,   DUR_8TH);      // B4
-            7'd18: data <= note(C5,   DUR_QUARTER);  // C5 (longer)
-            7'd19: data <= note(REST, DUR_8TH);      // Rest
-
-            //=================================================================
-            // A Section - Third phrase (bars 9-12) - repeat of first
-            // E4 E5 D#5 E5 D#5 E5 B4 D5 C5 A4
-            //=================================================================
-            7'd20: data <= note(E4,   DUR_8TH);      // E4
-            7'd21: data <= note(E5,   DUR_8TH);      // E5
-            7'd22: data <= note(Ds5,  DUR_8TH);      // D#5
-            7'd23: data <= note(E5,   DUR_8TH);      // E5
-            7'd24: data <= note(Ds5,  DUR_8TH);      // D#5
-            7'd25: data <= note(E5,   DUR_8TH);      // E5
-            7'd26: data <= note(B4,   DUR_8TH);      // B4
-            7'd27: data <= note(D5,   DUR_8TH);      // D5
-            7'd28: data <= note(C5,   DUR_8TH);      // C5
-            7'd29: data <= note(A4,   DUR_QUARTER);  // A4 (longer)
-            7'd30: data <= note(REST, DUR_8TH);      // Rest
-
-            //=================================================================
-            // A Section - Fourth phrase (bars 13-16)
-            // C4 E4 A4 B4 (rest) E4 C5 B4 A4
-            //=================================================================
-            7'd31: data <= note(C4,   DUR_8TH);      // C4
-            7'd32: data <= note(E4,   DUR_8TH);      // E4
-            7'd33: data <= note(A4,   DUR_8TH);      // A4
-            7'd34: data <= note(B4,   DUR_QUARTER);  // B4 (longer)
-            7'd35: data <= note(REST, DUR_8TH);      // Rest
-            7'd36: data <= note(E4,   DUR_8TH);      // E4
-            7'd37: data <= note(C5,   DUR_8TH);      // C5
-            7'd38: data <= note(B4,   DUR_8TH);      // B4
-            7'd39: data <= note(A4,   DUR_HALF);     // A4 (end of A section)
-            7'd40: data <= note(REST, DUR_QUARTER);  // Rest
-
-            //=================================================================
-            // A Section Repeat - First phrase again
-            //=================================================================
-            7'd41: data <= note(E5,   DUR_8TH);      // E5
-            7'd42: data <= note(Ds5,  DUR_8TH);      // D#5
-            7'd43: data <= note(E5,   DUR_8TH);      // E5
-            7'd44: data <= note(Ds5,  DUR_8TH);      // D#5
-            7'd45: data <= note(E5,   DUR_8TH);      // E5
-            7'd46: data <= note(B4,   DUR_8TH);      // B4
-            7'd47: data <= note(D5,   DUR_8TH);      // D5
-            7'd48: data <= note(C5,   DUR_8TH);      // C5
-            7'd49: data <= note(A4,   DUR_QUARTER);  // A4
-            7'd50: data <= note(REST, DUR_8TH);      // Rest
-
-            //=================================================================
-            // A Section Repeat - Second phrase
-            //=================================================================
-            7'd51: data <= note(C4,   DUR_8TH);      // C4
-            7'd52: data <= note(E4,   DUR_8TH);      // E4
-            7'd53: data <= note(A4,   DUR_8TH);      // A4
-            7'd54: data <= note(B4,   DUR_QUARTER);  // B4
-            7'd55: data <= note(REST, DUR_8TH);      // Rest
-            7'd56: data <= note(E4,   DUR_8TH);      // E4
-            7'd57: data <= note(Gs4,  DUR_8TH);      // G#4
-            7'd58: data <= note(B4,   DUR_8TH);      // B4
-            7'd59: data <= note(C5,   DUR_QUARTER);  // C5
-            7'd60: data <= note(REST, DUR_8TH);      // Rest
-
-            //=================================================================
-            // A Section Repeat - Third phrase
-            //=================================================================
-            7'd61: data <= note(E4,   DUR_8TH);      // E4
-            7'd62: data <= note(E5,   DUR_8TH);      // E5
-            7'd63: data <= note(Ds5,  DUR_8TH);      // D#5
-            7'd64: data <= note(E5,   DUR_8TH);      // E5
-            7'd65: data <= note(Ds5,  DUR_8TH);      // D#5
-            7'd66: data <= note(E5,   DUR_8TH);      // E5
-            7'd67: data <= note(B4,   DUR_8TH);      // B4
-            7'd68: data <= note(D5,   DUR_8TH);      // D5
-            7'd69: data <= note(C5,   DUR_8TH);      // C5
-            7'd70: data <= note(A4,   DUR_QUARTER);  // A4
-            7'd71: data <= note(REST, DUR_8TH);      // Rest
-
-            //=================================================================
-            // A Section Repeat - Fourth phrase (ending)
-            //=================================================================
-            7'd72: data <= note(C4,   DUR_8TH);      // C4
-            7'd73: data <= note(E4,   DUR_8TH);      // E4
-            7'd74: data <= note(A4,   DUR_8TH);      // A4
-            7'd75: data <= note(B4,   DUR_QUARTER);  // B4
-            7'd76: data <= note(REST, DUR_8TH);      // Rest
-            7'd77: data <= note(E4,   DUR_8TH);      // E4
-            7'd78: data <= note(C5,   DUR_8TH);      // C5
-            7'd79: data <= note(B4,   DUR_8TH);      // B4
-            7'd80: data <= note(A4,   DUR_WHOLE);    // A4 (final note)
-
-            //=================================================================
-            // End marker and padding
-            //=================================================================
-            7'd81: data <= note(REST, DUR_WHOLE);    // Final rest
+            // Simple ascending and descending C-major scale pattern
+            //=================================================================
+            7'd0:  data <= note(C4,   DUR_8TH);      // C4
+            7'd1:  data <= note(D4,   DUR_8TH);      // D4
+            7'd2:  data <= note(E4,   DUR_8TH);      // E4
+            7'd3:  data <= note(F4,   DUR_8TH);      // F4
+            7'd4:  data <= note(G4,   DUR_8TH);      // G4
+            7'd5:  data <= note(A4,   DUR_8TH);      // A4
+            7'd6:  data <= note(B4,   DUR_8TH);      // B4
+            7'd7:  data <= note(C5,   DUR_8TH);      // C5 (octave up)
+            7'd8:  data <= note(C5,   DUR_8TH);      // C5
+            7'd9:  data <= note(B4,   DUR_8TH);      // B4
+            7'd10: data <= note(A4,   DUR_8TH);      // A4
+            7'd11: data <= note(G4,   DUR_8TH);      // G4
+            7'd12: data <= note(F4,   DUR_8TH);      // F4
+            7'd13: data <= note(E4,   DUR_8TH);      // E4
+            7'd14: data <= note(D4,   DUR_8TH);      // D4
+            7'd15: data <= note(C4,   DUR_QUARTER);  // C4 (longer ending)
 
             // Padding with rests for remaining addresses
             default: data <= note(REST, DUR_QUARTER);
@@ -215,6 +113,6 @@ module melody_rom #(
     //-------------------------------------------------------------------------
     // Melody length output for sequencer
     //-------------------------------------------------------------------------
-    // The actual melody ends at address 81 (82 notes total)
+    // The actual melody ends at address 15 (16 notes total)
 
 endmodule
diff --git a/src/project.v b/src/project.v
index 92745095e4db954e6c797c04c00444fa3e8a17a6..8fae31cb77f1c219cad7c32c1f1cda95b16a7d74 100644
--- a/src/project.v
+++ b/src/project.v
@@ -9,23 +9,24 @@
 // Module: tt_um_tone_fm_tx
 //
 // Description:
-//   TinyTapeout wrapper for audio tone generator and FM transmitter.
-//   Plays musical melodies via FM modulation with DDS.
+//   TinyTapeout wrapper for simplified FM transmitter.
+//   Plays a C-major scale pattern via FM modulation.
+//   Optimized for reduced ASIC area.
 //
 // Pin Mapping:
 //   ui_in[0]   = enable      - Enable playback
 //   ui_in[1]   = loop        - Loop melody continuously
-//   ui_in[2]   = clk_2x_en   - Enable clock doubling
-//   ui_in[3]   = pwm_in      - External PWM audio input
+//   ui_in[2]   = reserved    - (unused)
+//   ui_in[3]   = reserved    - (unused)
 //   ui_in[7:4] = reserved
 //
 //   uo_out[0]  = fm_out      - FM modulated RF output
 //   uo_out[1]  = audio_out   - Audio frequency output (speaker)
 //   uo_out[2]  = playing     - Melody currently playing
 //   uo_out[3]  = melody_end  - Pulse at end of melody
-//   uo_out[7:4]= note_index[3:0] - Current note index (debug)
+//   uo_out[7:4]= status      - Status bits
 //
-//   uio[7:0]   = phase_inc[31:24] - Phase increment MSB (output mode)
+//   uio[7:0]   = outputs     - Bidirectional I/O (configured as outputs)
 //
 //-----------------------------------------------------------------------------
 
@@ -45,8 +46,7 @@ module tt_um_tone_fm_tx (
     //=========================================================================
     wire enable      = ui_in[0] & ena;
     wire loop        = ui_in[1];
-    wire clk_2x_en   = ui_in[2];
-    wire pwm_in      = ui_in[3];
+    // ui_in[2] and ui_in[3] reserved (unused)
 
     //=========================================================================
     // Internal Signals
@@ -56,23 +56,23 @@ module tt_um_tone_fm_tx (
     wire [31:0] phase_inc_out;
     wire        playing;
     wire        melody_end;
-    wire [6:0]  note_index;
+    wire [4:0]  note_index;
 
     //=========================================================================
-    // FM Transmitter Core
+    // FM Transmitter Core (Simplified)
     //=========================================================================
     fur_elise_fm_top #(
         .CLK_FREQ_HZ(50_000_000),           // TinyTapeout clock is ~50 MHz
         .CLOCKS_PER_16TH(50_000_000 / 8),   // 120 BPM
-        .MELODY_LENGTH(82),
+        .MELODY_LENGTH(16),                 // Simplified 16-note melody
         .PWM_FREQ_HZ(50_000)
     ) u_fur_elise (
         .clk           (clk),
         .rst_n         (rst_n),
         .enable        (enable),
         .loop          (loop),
-        .clk_2x_enable (clk_2x_en),
-        .pwm_in        (pwm_in),
+        .clk_2x_enable (1'b0),              // Disabled
+        .pwm_in        (1'b0),              // Disabled
         .fm_out        (fm_out),
         .audio_out     (audio_out),
         .phase_inc_out (phase_inc_out),
@@ -95,6 +95,6 @@ module tt_um_tone_fm_tx (
     assign uio_oe  = 8'hFF;  // All outputs
 
     // Suppress unused input warnings
-    wire _unused = &{uio_in, note_index[6:4], 1'b0};
+    wire _unused = &{uio_in, ui_in[7:2], note_index[4], 1'b0};
 
 endmodule
diff --git a/test/Makefile b/test/Makefile
index eccc91c774b4c7f28e666b9c80b55e49a4f21e17..a6cd3b11dfd160781254b5803c7277b757d4299d 100644
--- a/test/Makefile
+++ b/test/Makefile
@@ -1,25 +1,44 @@
-# TinyTapeout Fur Elise FM Testbench Makefile
+# Makefile
+# See https://docs.cocotb.org/en/stable/quickstart.html for more info
 
-IVERILOG = iverilog
-VVP = vvp
-GTKWAVE = gtkwave
+# defaults
+SIM ?= icarus
+TOPLEVEL_LANG ?= verilog
+SRC_DIR = $(PWD)/../src
+PROJECT_SOURCES = project.v fur_elise_fm_top.v melody_rom.v melody_sequencer.v fm_modulator.v audio_tone_generator.v
 
-SRC_DIR = ../src
-TB = tb.v
-SRC_FILES = $(wildcard $(SRC_DIR)/*.v)
+ifneq ($(GATES),yes)
 
-all: sim
+# RTL simulation:
+SIM_BUILD				= sim_build/rtl
+VERILOG_SOURCES += $(addprefix $(SRC_DIR)/,$(PROJECT_SOURCES))
 
-sim: tb
-	$(VVP) tb
+else
 
-tb: $(TB) $(SRC_FILES)
-	$(IVERILOG) -o tb $(TB) $(SRC_FILES)
+# Gate level simulation:
+SIM_BUILD				= sim_build/gl
+COMPILE_ARGS    += -DGL_TEST
+COMPILE_ARGS    += -DFUNCTIONAL
+COMPILE_ARGS    += -DUSE_POWER_PINS
+COMPILE_ARGS    += -DSIM
+COMPILE_ARGS    += -DUNIT_DELAY=\#1
+VERILOG_SOURCES += $(PDK_ROOT)/gf180mcuD/libs.ref/gf180mcu_fd_sc_mcu7t5v0/verilog/primitives.v
+VERILOG_SOURCES += $(PDK_ROOT)/gf180mcuD/libs.ref/gf180mcu_fd_sc_mcu7t5v0/verilog/gf180mcu_fd_sc_mcu7t5v0.v
 
-wave: sim
-	$(GTKWAVE) tb.vcd &
+# this gets copied in by the GDS action workflow
+VERILOG_SOURCES += $(PWD)/gate_level_netlist.v
 
-clean:
-	rm -f tb tb.vcd
+endif
 
-.PHONY: all sim wave clean
+# Allow sharing configuration between design and testbench via `include`:
+COMPILE_ARGS 		+= -I$(SRC_DIR)
+
+# Include the testbench sources:
+VERILOG_SOURCES += $(PWD)/tb.v
+TOPLEVEL = tb
+
+# List test modules to run, separated by commas and without the .py suffix:
+COCOTB_TEST_MODULES = test
+
+# include cocotb's make rules to take care of the simulator setup
+include $(shell cocotb-config --makefiles)/Makefile.sim
diff --git a/test/tb.v b/test/tb.v
index bf23d86206461003688d8fe3a5c81327cccb8b17..a3b271f9fd9383eabd83bacbc65e7a6a8333bc14 100644
--- a/test/tb.v
+++ b/test/tb.v
@@ -1,253 +1,49 @@
-/*
- * Copyright (c) 2024 Your Name
- * SPDX-License-Identifier: Apache-2.0
- */
-
 `default_nettype none
 `timescale 1ns / 1ps
 
-//-----------------------------------------------------------------------------
-// Testbench: tb
-//
-// Description:
-//   TinyTapeout testbench for F√ºr Elise FM transmitter.
-//
-// Usage:
-//   iverilog -o tb tb.v ../src/*.v
-//   vvp tb
-//   gtkwave tb.vcd
-//-----------------------------------------------------------------------------
-
-module tb;
-
-    //=========================================================================
-    // Test Parameters
-    //=========================================================================
-    localparam CLK_PERIOD_NS = 20;  // 50 MHz clock
-
-    //=========================================================================
-    // DUT Signals
-    //=========================================================================
-    reg         clk;
-    reg         rst_n;
-    reg         ena;
-    reg  [7:0]  ui_in;
-    wire [7:0]  uo_out;
-    reg  [7:0]  uio_in;
-    wire [7:0]  uio_out;
-    wire [7:0]  uio_oe;
-
-    //=========================================================================
-    // DUT Instantiation
-    //=========================================================================
-    tt_um_tone_fm_tx dut (
-        .ui_in   (ui_in),
-        .uo_out  (uo_out),
-        .uio_in  (uio_in),
-        .uio_out (uio_out),
-        .uio_oe  (uio_oe),
-        .ena     (ena),
-        .clk     (clk),
-        .rst_n   (rst_n)
-    );
-
-    //=========================================================================
-    // Clock Generation
-    //=========================================================================
-    initial clk = 0;
-    always #(CLK_PERIOD_NS/2) clk = ~clk;
-
-    //=========================================================================
-    // Signal Aliases for Readability
-    //=========================================================================
-    wire fm_out     = uo_out[0];
-    wire audio_out  = uo_out[1];
-    wire playing    = uo_out[2];
-    wire melody_end = uo_out[3];
-    wire [3:0] note_idx = uo_out[7:4];
-    wire [7:0] phase_msb = uio_out;
-
-    //=========================================================================
-    // Output Monitoring
-    //=========================================================================
-    reg fm_out_prev;
-    integer fm_transitions;
-
-    always @(posedge clk) begin
-        fm_out_prev <= fm_out;
-        if (fm_out && !fm_out_prev)
-            fm_transitions <= fm_transitions + 1;
-    end
-
-    //=========================================================================
-    // Helper Tasks
-    //=========================================================================
-    task reset_dut;
-        begin
-            rst_n = 0;
-            ena = 0;
-            ui_in = 8'h00;
-            uio_in = 8'h00;
-            fm_transitions = 0;
-            #100;
-            rst_n = 1;
-            ena = 1;
-            #100;
-        end
-    endtask
-
-    task wait_clocks;
-        input integer num_clocks;
-        begin
-            repeat (num_clocks) @(posedge clk);
-        end
-    endtask
-
-    //=========================================================================
-    // Test Sequence
-    //=========================================================================
-    integer test_passed;
-
-    initial begin
-        $dumpfile("tb.vcd");
-        $dumpvars(0, tb);
-
-        test_passed = 1;
-
-        $display("");
-        $display("================================================");
-        $display("TinyTapeout Fur Elise FM Testbench");
-        $display("================================================");
-        $display("");
-
-        //---------------------------------------------------------------------
-        // Test 1: Reset Behavior
-        //---------------------------------------------------------------------
-        $display("[TEST 1] Reset behavior...");
-        reset_dut();
-
-        if (playing !== 0) begin
-            $display("  FAIL: playing should be 0 after reset (enable=0)");
-            test_passed = 0;
-        end else begin
-            $display("  PASS: Clean reset state");
-        end
-
-        //---------------------------------------------------------------------
-        // Test 2: Enable Playback
-        //---------------------------------------------------------------------
-        $display("[TEST 2] Enable playback...");
-        reset_dut();
-        ui_in[0] = 1;  // enable
-        ui_in[1] = 1;  // loop
-
-        wait_clocks(5000);
-
-        if (!playing) begin
-            $display("  FAIL: Should be playing melody");
-            test_passed = 0;
-        end else begin
-            $display("  PASS: Melody playback active");
-            $display("  Phase MSB: 0x%02X", phase_msb);
-        end
-
-        //---------------------------------------------------------------------
-        // Test 3: FM Output Activity
-        //---------------------------------------------------------------------
-        $display("[TEST 3] FM output activity...");
-        fm_transitions = 0;
-        wait_clocks(10000);
-
-        if (fm_transitions > 0) begin
-            $display("  PASS: FM output toggling (%0d transitions)", fm_transitions);
-        end else begin
-            $display("  FAIL: No FM output transitions");
-            test_passed = 0;
-        end
-
-        //---------------------------------------------------------------------
-        // Test 4: Clock Doubling
-        //---------------------------------------------------------------------
-        $display("[TEST 4] Clock doubling...");
-        reset_dut();
-        ui_in[0] = 1;  // enable
-        ui_in[2] = 1;  // clk_2x_enable
-
-        fm_transitions = 0;
-        wait_clocks(10000);
-        $display("  FM transitions with 2x clock: %0d", fm_transitions);
-
-        //---------------------------------------------------------------------
-        // Test 5: Audio Output
-        //---------------------------------------------------------------------
-        $display("[TEST 5] Audio output...");
-        reset_dut();
-        ui_in[0] = 1;  // enable
-
-        begin : audio_test
-            integer audio_transitions;
-            reg audio_prev;
-            audio_transitions = 0;
-            audio_prev = 0;
-
-            repeat (50000) begin
-                @(posedge clk);
-                if (audio_out && !audio_prev)
-                    audio_transitions = audio_transitions + 1;
-                audio_prev = audio_out;
-            end
-
-            if (audio_transitions > 0) begin
-                $display("  PASS: Audio output active (%0d transitions)", audio_transitions);
-            end else begin
-                $display("  WARN: No audio transitions detected");
-            end
-        end
-
-        //---------------------------------------------------------------------
-        // Test 6: Loop Mode
-        //---------------------------------------------------------------------
-        $display("[TEST 6] Loop mode...");
-        reset_dut();
-        ui_in[0] = 1;  // enable
-        ui_in[1] = 1;  // loop
-
-        @(posedge melody_end);
-        $display("  First melody_end detected");
-
-        wait_clocks(5000);
-
-        if (!playing) begin
-            $display("  FAIL: Should still be playing in loop mode");
-            test_passed = 0;
-        end else begin
-            $display("  PASS: Loop mode continues playback");
-        end
-
-        //---------------------------------------------------------------------
-        // Test Summary
-        //---------------------------------------------------------------------
-        $display("");
-        $display("================================================");
-        if (test_passed) begin
-            $display("ALL TESTS PASSED");
-        end else begin
-            $display("SOME TESTS FAILED");
-        end
-        $display("================================================");
-        $display("");
-
-        wait_clocks(1000);
-        $finish;
-    end
-
-    //=========================================================================
-    // Timeout Watchdog
-    //=========================================================================
-    initial begin
-        #50_000_000;  // 50ms timeout
-        $display("TIMEOUT: Simulation took too long");
-        $finish;
-    end
+/* This testbench just instantiates the module and makes some convenient wires
+   that can be driven / tested by the cocotb test.py.
+*/
+module tb ();
+
+  // Dump the signals to a VCD file. You can view it with gtkwave or surfer.
+  initial begin
+    $dumpfile("tb.vcd");
+    $dumpvars(0, tb);
+    #1;
+  end
+
+  // Wire up the inputs and outputs:
+  reg clk;
+  reg rst_n;
+  reg ena;
+  reg [7:0] ui_in;
+  reg [7:0] uio_in;
+  wire [7:0] uo_out;
+  wire [7:0] uio_out;
+  wire [7:0] uio_oe;
+`ifdef GL_TEST
+  wire VPWR = 1'b1;
+  wire VGND = 1'b0;
+`endif
+
+  // Replace tt_um_example with your module name:
+  tt_um_tone_fm_tx user_project (
+
+      // Include power ports for the Gate Level test:
+`ifdef GL_TEST
+      .VPWR(VPWR),
+      .VGND(VGND),
+`endif
+
+      .ui_in  (ui_in),    // Dedicated inputs
+      .uo_out (uo_out),   // Dedicated outputs
+      .uio_in (uio_in),   // IOs: Input path
+      .uio_out(uio_out),  // IOs: Output path
+      .uio_oe (uio_oe),   // IOs: Enable path (active high: 0=input, 1=output)
+      .ena    (ena),      // enable - goes high when design is selected
+      .clk    (clk),      // clock
+      .rst_n  (rst_n)     // not reset
+  );
 
 endmodule
diff --git a/test/test.py b/test/test.py
index 26592e796f634036b7705543ffae3bad340fcd52..0816c2fd76130b2f8b2360703a3732afcb928d6b 100644
--- a/test/test.py
+++ b/test/test.py
@@ -23,18 +23,39 @@ async def test_project(dut):
     await ClockCycles(dut.clk, 10)
     dut.rst_n.value = 1
 
-    dut._log.info("Test project behavior")
+    dut._log.info("Test FM transmitter behavior")
 
-    # Set the input values you want to test
-    dut.ui_in.value = 20
-    dut.uio_in.value = 30
+    # Enable the FM transmitter and loop mode
+    # ui_in[0] = enable, ui_in[1] = loop
+    dut.ui_in.value = 0b00000011  # Enable and loop
 
-    # Wait for one clock cycle to see the output values
-    await ClockCycles(dut.clk, 1)
+    # Wait for the module to start
+    await ClockCycles(dut.clk, 10)
 
-    # The following assersion is just an example of how to check the output values.
-    # Change it to match the actual expected output of your module:
-    assert dut.uo_out.value == 50
+    # Check that playing signal goes high
+    # uo_out[2] = playing
+    uo_out_val = int(dut.uo_out.value)
+    playing = (uo_out_val >> 2) & 0x1
+    dut._log.info(f"Playing status: {playing}")
+    assert playing == 1, "Module should be playing"
+
+    # Check that we can read note index
+    # uo_out[7:4] = note_index[3:0]
+    note_index = (uo_out_val >> 4) & 0xF
+    dut._log.info(f"Note index: {note_index}")
+
+    # Wait longer and verify the note index advances
+    await ClockCycles(dut.clk, 1000)
+    uo_out_val = int(dut.uo_out.value)
+    note_index_new = (uo_out_val >> 4) & 0xF
+    dut._log.info(f"Note index after wait: {note_index_new}")
+
+    # Disable and check that playing stops
+    dut.ui_in.value = 0b00000000  # Disable
+    await ClockCycles(dut.clk, 10)
+    uo_out_val = int(dut.uo_out.value)
+    playing = (uo_out_val >> 2) & 0x1
+    dut._log.info(f"Playing status after disable: {playing}")
+    assert playing == 0, "Module should not be playing after disable"
 
-    # Keep testing the module by changing the input values, waiting for
-    # one or more clock cycles, and asserting the expected output values.
+    dut._log.info("Test completed successfully")
